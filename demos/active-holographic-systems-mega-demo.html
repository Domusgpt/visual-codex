<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Active Holographic Systems - 30 Variations Mega Demo</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap');
        
        body {
            margin: 0;
            background: #000;
            overflow: hidden;
            font-family: 'Orbitron', 'Courier New', monospace;
            height: 100vh;
            cursor: crosshair;
            background: radial-gradient(ellipse at center, #1a0033 0%, #000000 70%);
            user-select: none; /* Prevent text selection */
        }
        
        /* SINGLE HOLOGRAPHIC DISPLAY */
        .holographic-display {
            position: absolute;
            top: 10%;
            left: 10%;
            width: 80%;
            height: 80%;
            border-radius: 25px;
            overflow: hidden;
            transition: all 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            transform-style: preserve-3d;
            z-index: 10; /* Below control panel */
            /* Enable selective touch capture */
            touch-action: none;
            overscroll-behavior: none;
            
            /* Neoskeuomorphic shadow system */
            box-shadow: 
                0 20px 40px rgba(0, 0, 0, 0.4),
                0 8px 16px rgba(0, 0, 0, 0.3),
                inset 0 2px 4px rgba(255, 255, 255, 0.1),
                inset 0 -2px 2px rgba(0, 0, 0, 0.1),
                0 0 0 2px rgba(0, 255, 255, 0.3),
                0 0 30px rgba(0, 255, 255, 0.2);
        }
        
        .holographic-display:hover {
            transform: scale(1.02) translateZ(10px);
            box-shadow: 
                0 30px 60px rgba(0, 0, 0, 0.5),
                0 12px 24px rgba(0, 0, 0, 0.4),
                inset 0 3px 6px rgba(255, 255, 255, 0.15),
                inset 0 -3px 3px rgba(0, 0, 0, 0.15),
                0 0 0 3px rgba(0, 255, 255, 0.5),
                0 0 50px rgba(0, 255, 255, 0.3);
        }
        
        /* CONTROL PANEL */
        .control-panel {
            position: fixed;
            top: 30px;
            right: 30px;
            background: linear-gradient(135deg,
                rgba(0, 0, 0, 0.9) 0%,
                rgba(25, 0, 50, 0.8) 100%
            );
            padding: 20px;
            border-radius: 15px;
            border: 1px solid #00ffff;
            font-family: 'Orbitron', monospace;
            z-index: 2500; /* Higher than buttons */
            backdrop-filter: blur(25px);
            box-shadow: 
                0 10px 30px rgba(0, 0, 0, 0.6),
                inset 0 1px 1px rgba(255, 255, 255, 0.1),
                0 0 0 1px rgba(0, 255, 255, 0.2);
            /* Ensure UI controls work normally */
            touch-action: manipulation;
            pointer-events: auto;
            -webkit-touch-callout: none;
            -webkit-tap-highlight-color: transparent;
        }
        
        .variant-display {
            text-align: center;
            margin-bottom: 15px;
            color: #00ffff;
            font-size: 0.9rem;
        }
        
        .variant-number {
            font-size: 1.8rem;
            font-weight: bold;
            color: #ffffff;
            text-shadow: 0 0 10px rgba(0, 255, 255, 0.8);
        }
        
        .control-buttons {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }
        
        .control-btn {
            background: rgba(0, 255, 255, 0.2);
            border: 1px solid #00ffff;
            color: #00ffff;
            padding: 8px 16px;
            border-radius: 8px;
            cursor: pointer;
            /* Ensure buttons work on touch devices */
            touch-action: manipulation;
            pointer-events: auto;
            min-height: 44px; /* iOS touch target requirement */
            min-width: 44px;
            /* Force higher z-index and better mobile handling */
            position: relative;
            z-index: 3000;
            -webkit-tap-highlight-color: rgba(0, 255, 255, 0.3);
            -webkit-touch-callout: none;
            user-select: none;
            font-family: 'Orbitron', monospace;
            font-size: 0.8rem;
            transition: all 0.3s ease;
        }
        
        .control-btn:hover {
            background: rgba(0, 255, 255, 0.4);
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.5);
            transform: translateY(-2px);
        }
        
        .control-btn:active {
            transform: translateY(0);
        }
        
        .auto-cycle {
            margin-top: 10px;
            font-size: 0.7rem;
            color: rgba(255, 255, 255, 0.7);
            text-align: center;
        }
        
        /* HOLOGRAPHIC CANVAS LAYERS */
        canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            /* Infinite scroll and touch support */
            touch-action: none;
            overscroll-behavior: none;
        }
        
        /* EXPANDED VIEW */
        .expanded-view {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0, 0, 0, 0.95);
            z-index: 1000;
            display: none;
            backdrop-filter: blur(10px);
        }
        
        .expanded-view.active {
            display: block;
        }
        
        .expanded-card {
            position: absolute;
            top: 10%;
            left: 10%;
            width: 80%;
            height: 80%;
            border-radius: 25px;
            overflow: hidden;
            box-shadow: 
                0 30px 60px rgba(0, 0, 0, 0.8),
                inset 0 2px 4px rgba(255, 255, 255, 0.1),
                0 0 0 2px rgba(0, 255, 255, 0.4),
                0 0 40px rgba(0, 255, 255, 0.3);
        }
        
        .close-button {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 255, 255, 0.2);
            border: 1px solid #00ffff;
            color: #00ffff;
            padding: 12px 20px;
            border-radius: 10px;
            cursor: pointer;
            font-family: 'Orbitron', monospace;
            font-size: 0.9rem;
            z-index: 1001;
            transition: all 0.3s ease;
        }
        
        .close-button:hover {
            background: rgba(0, 255, 255, 0.4);
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.5);
        }
        
        /* GRID OVERLAY SYSTEM */
        .grid-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 20;
            opacity: 0.1;
            transition: opacity 0.3s ease;
            background: 
                repeating-linear-gradient(0deg, transparent, transparent 20px, rgba(0, 255, 255, 0.1) 20px, rgba(0, 255, 255, 0.1) 21px),
                repeating-linear-gradient(90deg, transparent, transparent 20px, rgba(0, 255, 255, 0.1) 20px, rgba(0, 255, 255, 0.1) 21px);
        }
        
        .grid-overlay.active {
            opacity: 0.3;
        }
        
        /* INTERACTION RIPPLE */
        .interaction-ripple {
            position: absolute;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(0, 255, 255, 0.6) 0%, transparent 70%);
            pointer-events: none;
            z-index: 30;
            animation: rippleExpand 0.6s ease-out forwards;
        }
        
        @keyframes rippleExpand {
            0% { width: 0; height: 0; opacity: 1; }
            100% { width: 100px; height: 100px; opacity: 0; }
        }
    </style>
</head>
<body>
    <!-- GRID OVERLAY -->
    <div class="grid-overlay" id="gridOverlay"></div>
    
    <!-- CONTROL PANEL -->
    <div class="control-panel">
        <div class="variant-display">
            <div>HOLOGRAPHIC VARIANT</div>
            <div class="variant-number" id="variantNumber">01</div>
            <div id="variantName">HYPERCUBE LATTICE</div>
        </div>
        <div class="control-buttons">
            <button class="control-btn" onclick="previousVariant()">‚óÄ PREV</button>
            <button class="control-btn" onclick="nextVariant()">NEXT ‚ñ∂</button>
        </div>
        <div class="control-buttons">
            <button class="control-btn" onclick="randomVariant()">üé≤ RANDOM</button>
            <button class="control-btn" onclick="toggleAutoCycle()" id="autoCycleBtn">‚è∏ AUTO</button>
        </div>
        <div class="auto-cycle" id="autoCycleStatus">Auto-cycle: OFF</div>
    </div>
    
    <!-- SINGLE HOLOGRAPHIC DISPLAY -->
    <div class="holographic-display" id="holographicDisplay">
        <!-- 5-layer holographic system -->
        <canvas id="background-canvas" style="z-index: 1; opacity: 0.2;"></canvas>
        <canvas id="shadow-canvas" style="z-index: 3; opacity: 0.6; filter: blur(2px) brightness(0.7); mix-blend-mode: multiply; transform: translate(2px, 2px);"></canvas>
        <canvas id="content-canvas" style="z-index: 5; opacity: 0.8; mix-blend-mode: normal;"></canvas>
        <canvas id="highlight-canvas" style="z-index: 7; opacity: 0.4; filter: blur(1px) brightness(1.5); mix-blend-mode: screen; transform: translate(-1px, -1px);"></canvas>
        <canvas id="accent-canvas" style="z-index: 15; opacity: 0.3; filter: blur(2px); mix-blend-mode: color-dodge; transform: scale(1.01);"></canvas>
    </div>

    <script>
        console.log('üåå Active Holographic Systems - 30 Variations Mega Demo');
        
        // COMPLETE HOLOGRAPHIC VISUALIZER WITH FULL REACTIVITY
        class CompleteHolographicVisualizer {
            constructor(canvasId, role = 'content', reactivity = 1.0, variant = 0) {
                this.canvas = document.getElementById(canvasId);
                this.role = role;
                this.reactivity = reactivity;
                this.variant = variant;
                this.gl = this.canvas.getContext('webgl');
                
                if (!this.gl) {
                    console.error(`WebGL not supported for ${canvasId}`);
                    return;
                }
                
                // VARIATION-SPECIFIC PARAMETERS
                this.variantParams = this.generateVariantParams(variant);
                
                // EXACT role-specific parameters from tech-layout with variant customization
                this.roleParams = {
                    'background': { 
                        densityMult: 0.4, speedMult: 0.2, colorShift: 0.0, intensity: 0.2,
                        mouseReactivity: 0.3, clickReactivity: 0.1 
                    },
                    'shadow': { 
                        densityMult: 0.8, speedMult: 0.3, colorShift: 180.0, intensity: 0.4,
                        mouseReactivity: 0.5, clickReactivity: 0.3 
                    },
                    'content': { 
                        densityMult: this.variantParams.density, speedMult: this.variantParams.speed, 
                        colorShift: this.variantParams.hue, intensity: this.variantParams.intensity,
                        mouseReactivity: 1.0, clickReactivity: 0.8 
                    },
                    'highlight': { 
                        densityMult: 1.5 + (this.variantParams.density * 0.3), speedMult: 0.8 + (this.variantParams.speed * 0.2), 
                        colorShift: this.variantParams.hue + 60.0, intensity: 0.6 + (this.variantParams.intensity * 0.2),
                        mouseReactivity: 1.2, clickReactivity: 1.0 
                    },
                    'accent': { 
                        densityMult: 2.5 + (this.variantParams.density * 0.5), speedMult: 0.4 + (this.variantParams.speed * 0.1), 
                        colorShift: this.variantParams.hue + 300.0, intensity: 0.3 + (this.variantParams.intensity * 0.1),
                        mouseReactivity: 1.5, clickReactivity: 1.2 
                    }
                }[role] || { densityMult: 1.0, speedMult: 0.5, colorShift: 0.0, intensity: 0.5, mouseReactivity: 1.0, clickReactivity: 0.5 };
                
                // EXACT state system from tech-layout
                this.currentState = 1; // TECH
                this.targetState = 1;
                this.transitionProgress = 1.0;
                this.chaosIntensity = 0.0;
                
                // ENHANCED INTERACTION SYSTEM - Mouse, Touch, and Scroll
                this.mouseX = 0.5;
                this.mouseY = 0.5;
                this.mouseIntensity = 0.0;
                this.clickIntensity = 0.0;
                this.clickDecay = 0.95;
                
                // Touch interaction system
                this.touchX = 0.5;
                this.touchY = 0.5;
                this.touchActive = false;
                this.touchMorph = 0.0; // X-axis controls morph
                this.touchChaos = 0.0; // Y-axis controls chaos
                
                // Scroll parallax system
                this.scrollPosition = 0.0;
                this.scrollVelocity = 0.0;
                this.scrollDecay = 0.92;
                this.parallaxDepth = 0.0;
                this.gridDensityShift = 0.0;
                this.colorScrollShift = 0.0;
                
                // EXACT density system with variations
                this.baseDensity = 6.0 + Math.random() * 4.0;
                this.densityVariation = 0.0;
                this.densityTarget = 0.0;
                
                this.startTime = Date.now();
                this.initShaders();
                this.initBuffers();
                this.resize();
            }
            
            generateVariantParams(variant) {
                // VIB3 8-GEOMETRY SYSTEM: 30 variations from 8 base geometries
                const vib3Geometries = [
                    'TETRAHEDRON', 'HYPERCUBE', 'SPHERE', 'TORUS', 
                    'KLEIN BOTTLE', 'FRACTAL', 'WAVE', 'CRYSTAL'
                ];
                
                const baseGeometry = Math.floor(variant % 8);
                const variationLevel = Math.floor(variant / 8); // 0, 1, 2, 3 (for sub-variations)
                const geometryName = vib3Geometries[baseGeometry];
                
                // Variation suffixes for sub-types
                const suffixes = ['', ' FIELD', ' MATRIX', ' LATTICE'];
                const finalName = geometryName + (suffixes[variationLevel] || '');
                
                // Base parameters for each geometry type
                const geometryConfigs = {
                    0: { // TETRAHEDRON
                        density: 0.8 + variationLevel * 0.2,
                        speed: 0.3 + variationLevel * 0.1,
                        chaos: variationLevel * 0.1,
                        morph: 0.0
                    },
                    1: { // HYPERCUBE  
                        density: 1.0 + variationLevel * 0.3,
                        speed: 0.5 + variationLevel * 0.1,
                        chaos: variationLevel * 0.15,
                        morph: variationLevel * 0.2
                    },
                    2: { // SPHERE
                        density: 1.2 + variationLevel * 0.4,
                        speed: 0.4 + variationLevel * 0.2,
                        chaos: 0.1 + variationLevel * 0.1,
                        morph: 0.3 + variationLevel * 0.2
                    },
                    3: { // TORUS
                        density: 0.9 + variationLevel * 0.3,
                        speed: 0.6 + variationLevel * 0.2,
                        chaos: 0.2 + variationLevel * 0.2,
                        morph: 0.5 + variationLevel * 0.1
                    },
                    4: { // KLEIN BOTTLE
                        density: 1.4 + variationLevel * 0.5,
                        speed: 0.7 + variationLevel * 0.1,
                        chaos: 0.3 + variationLevel * 0.2,
                        morph: 0.7 + variationLevel * 0.1
                    },
                    5: { // FRACTAL
                        density: 1.8 + variationLevel * 0.3,
                        speed: 0.5 + variationLevel * 0.3,
                        chaos: 0.5 + variationLevel * 0.2,
                        morph: 0.8 + variationLevel * 0.05
                    },
                    6: { // WAVE
                        density: 0.6 + variationLevel * 0.4,
                        speed: 0.8 + variationLevel * 0.4,
                        chaos: 0.4 + variationLevel * 0.3,
                        morph: 0.6 + variationLevel * 0.2
                    },
                    7: { // CRYSTAL
                        density: 1.6 + variationLevel * 0.2,
                        speed: 0.2 + variationLevel * 0.1,
                        chaos: 0.1 + variationLevel * 0.1,
                        morph: 0.2 + variationLevel * 0.2
                    }
                };
                
                const config = geometryConfigs[baseGeometry];
                
                return {
                    geometryType: baseGeometry,
                    name: finalName,
                    density: config.density,
                    speed: config.speed,
                    hue: (variant * 12.27) % 360,
                    intensity: 0.5 + (variationLevel * 0.1),
                    chaos: config.chaos,
                    morph: config.morph
                };
            }
            
            initShaders() {
                const vertexShaderSource = `
                    attribute vec2 a_position;
                    void main() {
                        gl_Position = vec4(a_position, 0.0, 1.0);
                    }
                `;
                
                const fragmentShaderSource = `
                    precision highp float;
                    
                    uniform vec2 u_resolution;
                    uniform float u_time;
                    uniform vec2 u_mouse;
                    uniform float u_geometry;
                    uniform float u_density;
                    uniform float u_speed;
                    uniform vec3 u_color;
                    uniform float u_intensity;
                    uniform float u_roleDensity;
                    uniform float u_roleSpeed;
                    uniform float u_colorShift;
                    uniform float u_chaosIntensity;
                    uniform float u_mouseIntensity;
                    uniform float u_clickIntensity;
                    uniform float u_densityVariation;
                    uniform float u_geometryType;
                    uniform float u_chaos;
                    uniform float u_morph;
                    uniform float u_touchMorph;
                    uniform float u_touchChaos;
                    uniform float u_scrollParallax;
                    uniform float u_gridDensityShift;
                    uniform float u_colorScrollShift;
                    
                    // EXACT 4D rotation matrices from tech-layout
                    mat4 rotateXW(float theta) {
                        float c = cos(theta);
                        float s = sin(theta);
                        return mat4(c, 0, 0, -s, 0, 1, 0, 0, 0, 0, 1, 0, s, 0, 0, c);
                    }
                    
                    mat4 rotateYW(float theta) {
                        float c = cos(theta);
                        float s = sin(theta);
                        return mat4(1, 0, 0, 0, 0, c, 0, -s, 0, 0, 1, 0, 0, s, 0, c);
                    }
                    
                    mat4 rotateZW(float theta) {
                        float c = cos(theta);
                        float s = sin(theta);
                        return mat4(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, c, -s, 0, 0, s, c);
                    }
                    
                    // EXACT 4D to 3D projection from tech-layout
                    vec3 project4Dto3D(vec4 p) {
                        float w = 2.5 / (2.5 + p.w);
                        return vec3(p.x * w, p.y * w, p.z * w);
                    }
                    
                    // EXACT tetrahedron lattice from tech-layout
                    float tetrahedronLattice(vec3 p, float gridSize) {
                        vec3 q = fract(p * gridSize) - 0.5;
                        
                        // Tetrahedron vertices
                        float d1 = length(q);
                        float d2 = length(q - vec3(0.4, 0.0, 0.0));
                        float d3 = length(q - vec3(0.0, 0.4, 0.0));
                        float d4 = length(q - vec3(0.0, 0.0, 0.4));
                        
                        float vertices = 1.0 - smoothstep(0.0, 0.04, min(min(d1, d2), min(d3, d4)));
                        
                        // Edge connections
                        float edges = 0.0;
                        edges = max(edges, 1.0 - smoothstep(0.0, 0.02, abs(length(q.xy) - 0.2)));
                        edges = max(edges, 1.0 - smoothstep(0.0, 0.02, abs(length(q.yz) - 0.2)));
                        edges = max(edges, 1.0 - smoothstep(0.0, 0.02, abs(length(q.xz) - 0.2)));
                        
                        return max(vertices, edges * 0.5);
                    }
                    
                    // VIB3 GEOMETRY LIBRARY - REAL MATHEMATICAL FOUNDATIONS
                    
                    // HYPERCUBE LATTICE - Grid-based edges and vertices
                    float hypercubeLattice(vec3 p, float gridSize) {
                        vec3 grid = fract(p * gridSize);
                        vec3 edges = 1.0 - smoothstep(0.0, 0.03, abs(grid - 0.5));
                        return max(max(edges.x, edges.y), edges.z);
                    }
                    
                    // SPHERE LATTICE - Radial distance fields
                    float sphereLattice(vec3 p, float gridSize) {
                        vec3 q = fract(p * gridSize) - 0.5;
                        float r = length(q);
                        return 1.0 - smoothstep(0.2, 0.5, r);
                    }
                    
                    // TORUS LATTICE - Double-radius torus mathematics
                    float torusLattice(vec3 p, float gridSize) {
                        vec3 q = fract(p * gridSize) - 0.5;
                        float r1 = sqrt(q.x*q.x + q.y*q.y);
                        float r2 = sqrt((r1 - 0.3)*(r1 - 0.3) + q.z*q.z);
                        return 1.0 - smoothstep(0.0, 0.1, r2);
                    }
                    
                    // KLEIN BOTTLE - Non-orientable surface with parametric equations
                    float kleinLattice(vec3 p, float gridSize) {
                        vec3 q = fract(p * gridSize);
                        float u = q.x * 2.0 * 3.14159;
                        float v = q.y * 2.0 * 3.14159;
                        float x = cos(u) * (3.0 + cos(u/2.0) * sin(v) - sin(u/2.0) * sin(2.0*v));
                        float klein = length(vec2(x, q.z)) - 0.1;
                        return 1.0 - smoothstep(0.0, 0.05, abs(klein));
                    }
                    
                    // FRACTAL LATTICE - Recursive self-similar scaling
                    float fractalLattice(vec3 p, float gridSize) {
                        vec3 q = p * gridSize;
                        float scale = 1.0;
                        float fractal = 0.0;
                        for(int i = 0; i < 4; i++) {
                          q = fract(q) - 0.5;
                          fractal += abs(length(q)) / scale;
                          scale *= 2.0;
                          q *= 2.0;
                        }
                        return 1.0 - smoothstep(0.0, 1.0, fractal);
                    }
                    
                    // WAVE LATTICE - Sine wave interference patterns
                    float waveLattice(vec3 p, float gridSize) {
                        vec3 q = p * gridSize;
                        float wave = sin(q.x * 2.0) * sin(q.y * 2.0) * sin(q.z * 2.0 + u_time);
                        return smoothstep(-0.5, 0.5, wave);
                    }
                    
                    // CRYSTAL LATTICE - Cubic/box distance fields
                    float crystalLattice(vec3 p, float gridSize) {
                        vec3 q = fract(p * gridSize) - 0.5;
                        float d = max(max(abs(q.x), abs(q.y)), abs(q.z));
                        return 1.0 - smoothstep(0.3, 0.5, d);
                    }
                    
                    // DYNAMIC GEOMETRY SELECTOR - Based on VIB3 8-geometry system
                    float getDynamicGeometry(vec3 p, float gridSize, float geometryType) {
                        // Create 30 variations from 8 base geometries (3-4 variations each)
                        int baseGeom = int(mod(geometryType, 8.0));
                        float variation = floor(geometryType / 8.0) / 4.0; // 0.0, 0.25, 0.5, 0.75
                        
                        // Apply variation to grid size
                        float variedGridSize = gridSize * (0.5 + variation * 1.5);
                        
                        if (baseGeom == 0) return tetrahedronLattice(p, variedGridSize);
                        else if (baseGeom == 1) return hypercubeLattice(p, variedGridSize);
                        else if (baseGeom == 2) return sphereLattice(p, variedGridSize);
                        else if (baseGeom == 3) return torusLattice(p, variedGridSize);
                        else if (baseGeom == 4) return kleinLattice(p, variedGridSize);
                        else if (baseGeom == 5) return fractalLattice(p, variedGridSize);
                        else if (baseGeom == 6) return waveLattice(p, variedGridSize);
                        else return crystalLattice(p, variedGridSize);
                    }
                    
                    vec3 hsv2rgb(vec3 c) {
                        vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
                        vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
                        return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
                    }
                    
                    // EXACT holographic effects from tech-layout
                    vec3 rgbGlitch(vec3 color, vec2 uv, float intensity) {
                        vec2 offset = vec2(intensity * 0.005, 0.0);
                        float r = color.r + sin(uv.y * 30.0 + u_time * 0.001) * intensity * 0.06;
                        float g = color.g + sin(uv.y * 28.0 + u_time * 0.0012) * intensity * 0.06;
                        float b = color.b + sin(uv.y * 32.0 + u_time * 0.0008) * intensity * 0.06;
                        return vec3(r, g, b);
                    }
                    
                    float moirePattern(vec2 uv, float intensity) {
                        float freq1 = 12.0 + intensity * 6.0 + u_densityVariation * 3.0;
                        float freq2 = 14.0 + intensity * 8.0 + u_densityVariation * 4.0;
                        float pattern1 = sin(uv.x * freq1) * sin(uv.y * freq1);
                        float pattern2 = sin(uv.x * freq2) * sin(uv.y * freq2);
                        return (pattern1 * pattern2) * intensity * 0.15;
                    }
                    
                    float gridOverlay(vec2 uv, float intensity) {
                        vec2 grid = fract(uv * (8.0 + u_densityVariation * 4.0));
                        float lines = 0.0;
                        lines = max(lines, 1.0 - smoothstep(0.0, 0.02, abs(grid.x - 0.5)));
                        lines = max(lines, 1.0 - smoothstep(0.0, 0.02, abs(grid.y - 0.5)));
                        return lines * intensity * 0.1;
                    }
                    
                    void main() {
                        vec2 uv = gl_FragCoord.xy / u_resolution.xy;
                        float aspectRatio = u_resolution.x / u_resolution.y;
                        uv.x *= aspectRatio;
                        uv -= 0.5;
                        
                        // ENHANCED 4D space with mouse, touch, and scroll reactivity
                        float time = u_time * 0.0004 * u_speed * u_roleSpeed;
                        
                        // Mouse influence on rotation
                        float mouseInfluence = u_mouseIntensity * 0.5;
                        vec2 mouseOffset = (u_mouse - 0.5) * mouseInfluence;
                        
                        // Scroll parallax influence on depth
                        float parallaxOffset = u_scrollParallax * 0.2;
                        vec2 scrollOffset = vec2(parallaxOffset * 0.1, parallaxOffset * 0.05);
                        
                        // Touch morph influence on 4D position
                        float morphOffset = u_touchMorph * 0.3;
                        
                        vec4 p4d = vec4(uv + mouseOffset * 0.1 + scrollOffset, 
                                       sin(time * 0.1 + morphOffset) * 0.15, 
                                       cos(time * 0.08 + morphOffset * 0.5) * 0.15);
                        
                        // ENHANCED 4D rotations with mouse, touch, and scroll reactivity
                        float scrollRotation = u_scrollParallax * 0.1;
                        float touchRotation = u_touchMorph * 0.2;
                        
                        p4d = rotateXW(time * 0.2 + mouseOffset.y * 0.5 + scrollRotation) * p4d;
                        p4d = rotateYW(time * 0.15 + mouseOffset.x * 0.5 + touchRotation) * p4d;
                        p4d = rotateZW(time * 0.25 + u_clickIntensity * 0.3 + u_touchChaos * 0.4) * p4d;
                        
                        vec3 p = project4Dto3D(p4d);
                        
                        // ENHANCED dynamic density with scroll and touch variations
                        float scrollDensityMod = 1.0 + u_gridDensityShift * 0.3;
                        float roleDensity = ((u_density + u_densityVariation) * u_roleDensity) * scrollDensityMod;
                        
                        // Get dynamic geometry with touch morph influence
                        float morphedGeometry = u_geometryType + u_touchMorph * 2.0;
                        float lattice = getDynamicGeometry(p, roleDensity, morphedGeometry);
                        
                        // ENHANCED coloring with mouse, touch, and scroll reactivity
                        float hue = atan(u_color.r, u_color.g) + u_colorShift * 0.017453 + u_mouseIntensity * 0.2 + u_colorScrollShift;
                        float saturation = 0.8 + lattice * 0.2 + u_clickIntensity * 0.1 + u_touchChaos * 0.15;
                        float brightness = 0.2 + lattice * 0.8 + u_intensity * 0.2 + u_mouseIntensity * 0.15 + u_touchMorph * 0.1;
                        
                        vec3 color = hsv2rgb(vec3(hue, saturation, brightness));
                        
                        // Add ENHANCED holographic effects with touch and scroll
                        float enhancedChaos = u_chaosIntensity + u_touchChaos * 0.3;
                        color += vec3(moirePattern(uv + scrollOffset, enhancedChaos));
                        color += vec3(gridOverlay(uv, u_mouseIntensity + u_scrollParallax * 0.1));
                        color = rgbGlitch(color, uv, enhancedChaos);
                        
                        // EXACT mouse interaction glow from tech-layout
                        float mouseDist = length(uv - (u_mouse - 0.5) * vec2(aspectRatio, 1.0));
                        float mouseGlow = exp(-mouseDist * 1.5) * u_mouseIntensity * 0.2;
                        color += vec3(mouseGlow) * u_color * 0.6;
                        
                        // EXACT click pulse effect from tech-layout
                        float clickPulse = u_clickIntensity * exp(-mouseDist * 2.0) * 0.3;
                        color += vec3(clickPulse, clickPulse * 0.5, clickPulse * 1.5);
                        
                        gl_FragColor = vec4(color, 0.95);
                    }
                `;
                
                this.program = this.createProgram(vertexShaderSource, fragmentShaderSource);
                this.uniforms = {
                    resolution: this.gl.getUniformLocation(this.program, 'u_resolution'),
                    time: this.gl.getUniformLocation(this.program, 'u_time'),
                    mouse: this.gl.getUniformLocation(this.program, 'u_mouse'),
                    geometry: this.gl.getUniformLocation(this.program, 'u_geometry'),
                    density: this.gl.getUniformLocation(this.program, 'u_density'),
                    speed: this.gl.getUniformLocation(this.program, 'u_speed'),
                    color: this.gl.getUniformLocation(this.program, 'u_color'),
                    intensity: this.gl.getUniformLocation(this.program, 'u_intensity'),
                    roleDensity: this.gl.getUniformLocation(this.program, 'u_roleDensity'),
                    roleSpeed: this.gl.getUniformLocation(this.program, 'u_roleSpeed'),
                    colorShift: this.gl.getUniformLocation(this.program, 'u_colorShift'),
                    chaosIntensity: this.gl.getUniformLocation(this.program, 'u_chaosIntensity'),
                    mouseIntensity: this.gl.getUniformLocation(this.program, 'u_mouseIntensity'),
                    clickIntensity: this.gl.getUniformLocation(this.program, 'u_clickIntensity'),
                    densityVariation: this.gl.getUniformLocation(this.program, 'u_densityVariation'),
                    geometryType: this.gl.getUniformLocation(this.program, 'u_geometryType'),
                    chaos: this.gl.getUniformLocation(this.program, 'u_chaos'),
                    morph: this.gl.getUniformLocation(this.program, 'u_morph'),
                    touchMorph: this.gl.getUniformLocation(this.program, 'u_touchMorph'),
                    touchChaos: this.gl.getUniformLocation(this.program, 'u_touchChaos'),
                    scrollParallax: this.gl.getUniformLocation(this.program, 'u_scrollParallax'),
                    gridDensityShift: this.gl.getUniformLocation(this.program, 'u_gridDensityShift'),
                    colorScrollShift: this.gl.getUniformLocation(this.program, 'u_colorScrollShift')
                };
            }
            
            createProgram(vertexSource, fragmentSource) {
                const vertexShader = this.createShader(this.gl.VERTEX_SHADER, vertexSource);
                const fragmentShader = this.createShader(this.gl.FRAGMENT_SHADER, fragmentSource);
                
                const program = this.gl.createProgram();
                this.gl.attachShader(program, vertexShader);
                this.gl.attachShader(program, fragmentShader);
                this.gl.linkProgram(program);
                
                if (!this.gl.getProgramParameter(program, this.gl.LINK_STATUS)) {
                    console.error('Program linking failed:', this.gl.getProgramInfoLog(program));
                    return null;
                }
                
                return program;
            }
            
            createShader(type, source) {
                const shader = this.gl.createShader(type);
                this.gl.shaderSource(shader, source);
                this.gl.compileShader(shader);
                
                if (!this.gl.getShaderParameter(shader, this.gl.COMPILE_STATUS)) {
                    console.error('Shader compilation failed:', this.gl.getShaderInfoLog(shader));
                    return null;
                }
                
                return shader;
            }
            
            initBuffers() {
                const positions = new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]);
                
                this.buffer = this.gl.createBuffer();
                this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.buffer);
                this.gl.bufferData(this.gl.ARRAY_BUFFER, positions, this.gl.STATIC_DRAW);
                
                const positionLocation = this.gl.getAttribLocation(this.program, 'a_position');
                this.gl.enableVertexAttribArray(positionLocation);
                this.gl.vertexAttribPointer(positionLocation, 2, this.gl.FLOAT, false, 0, 0);
            }
            
            resize() {
                this.canvas.width = this.canvas.clientWidth;
                this.canvas.height = this.canvas.clientHeight;
                this.gl.viewport(0, 0, this.canvas.width, this.canvas.height);
            }
            
            updateInteraction(mouseX, mouseY, intensity) {
                this.mouseX = mouseX;
                this.mouseY = mouseY;
                this.mouseIntensity = intensity * this.roleParams.mouseReactivity * this.reactivity;
            }
            
            triggerClick(x, y) {
                this.clickIntensity = Math.min(1.0, this.clickIntensity + this.roleParams.clickReactivity * this.reactivity);
            }
            
            updateDensity(variation) {
                this.densityTarget = variation;
            }
            
            // NEW TOUCH INTERACTION METHODS
            updateTouch(touchX, touchY, active) {
                this.touchX = touchX;
                this.touchY = touchY;
                this.touchActive = active;
                
                // X-axis controls morph (horizontal swipe)
                this.touchMorph = (touchX - 0.5) * 2.0; // -1 to 1 range
                
                // Y-axis controls chaos (vertical swipe)
                this.touchChaos = Math.abs(touchY - 0.5) * 2.0; // 0 to 1 range
            }
            
            // NEW SCROLL INTERACTION METHODS
            updateScroll(deltaY) {
                // Accumulate scroll for continuous parallax
                this.scrollVelocity += deltaY * 0.001; // Scale scroll input
                this.scrollVelocity = Math.max(-2.0, Math.min(2.0, this.scrollVelocity)); // Clamp velocity
            }
            
            updateScrollPhysics() {
                // Apply scroll velocity to position
                this.scrollPosition += this.scrollVelocity;
                
                // Apply decay to velocity
                this.scrollVelocity *= this.scrollDecay;
                
                // Update parallax depth based on scroll position
                this.parallaxDepth = Math.sin(this.scrollPosition * 0.1) * 0.5;
                
                // Update grid density shift (subtle)
                this.gridDensityShift = Math.sin(this.scrollPosition * 0.05) * 0.3;
                
                // Update color scroll shift (gradual hue rotation)
                this.colorScrollShift = (this.scrollPosition * 0.02) % (Math.PI * 2);
            }
            
            render() {
                if (!this.program) return;
                
                this.resize();
                this.gl.useProgram(this.program);
                
                this.densityVariation += (this.densityTarget - this.densityVariation) * 0.05;
                this.clickIntensity *= this.clickDecay;
                
                // Update scroll physics
                this.updateScrollPhysics();
                
                const time = Date.now() - this.startTime;
                
                // Set uniforms
                this.gl.uniform2f(this.uniforms.resolution, this.canvas.width, this.canvas.height);
                this.gl.uniform1f(this.uniforms.time, time);
                this.gl.uniform2f(this.uniforms.mouse, this.mouseX, this.mouseY);
                this.gl.uniform1f(this.uniforms.geometry, 1.0);
                this.gl.uniform1f(this.uniforms.density, 4.2);
                this.gl.uniform1f(this.uniforms.speed, 0.3);
                this.gl.uniform3fv(this.uniforms.color, new Float32Array([0.0, 1.0, 1.0]));
                this.gl.uniform1f(this.uniforms.intensity, this.roleParams.intensity);
                this.gl.uniform1f(this.uniforms.roleDensity, this.roleParams.densityMult);
                this.gl.uniform1f(this.uniforms.roleSpeed, this.roleParams.speedMult);
                this.gl.uniform1f(this.uniforms.colorShift, this.roleParams.colorShift);
                this.gl.uniform1f(this.uniforms.chaosIntensity, this.variantParams.chaos || 0.0);
                this.gl.uniform1f(this.uniforms.mouseIntensity, this.mouseIntensity);
                this.gl.uniform1f(this.uniforms.clickIntensity, this.clickIntensity);
                this.gl.uniform1f(this.uniforms.densityVariation, this.densityVariation);
                this.gl.uniform1f(this.uniforms.geometryType, this.variant);
                this.gl.uniform1f(this.uniforms.chaos, this.variantParams.chaos || 0.0);
                this.gl.uniform1f(this.uniforms.morph, this.variantParams.morph || 0.0);
                
                // Set touch and scroll uniforms
                this.gl.uniform1f(this.uniforms.touchMorph, this.touchMorph);
                this.gl.uniform1f(this.uniforms.touchChaos, this.touchChaos);
                this.gl.uniform1f(this.uniforms.scrollParallax, this.parallaxDepth);
                this.gl.uniform1f(this.uniforms.gridDensityShift, this.gridDensityShift);
                this.gl.uniform1f(this.uniforms.colorScrollShift, this.colorScrollShift);
                
                this.gl.drawArrays(this.gl.TRIANGLE_STRIP, 0, 4);
            }
        }
        
        // HOLOGRAPHIC CYCLING SYSTEM
        class HolographicCyclingSystem {
            constructor() {
                this.visualizers = [];
                this.currentVariant = 0;
                this.totalVariants = 30;
                this.autoCycleActive = false;
                this.autoCycleInterval = null;
                this.mouseX = 0.5;
                this.mouseY = 0.5;
                this.mouseIntensity = 0.0;
                
                // Variant names for display
                this.variantNames = [
                    'HYPERCUBE LATTICE', 'PLASMA FIELD', 'CRYSTAL MATRIX', 'NEURAL NETWORK', 'QUANTUM FOAM',
                    'FRACTAL DIMENSION', 'HOLOGRAPHIC CORE', 'ENERGY VORTEX', 'PARTICLE STORM', 'WAVE FUNCTION',
                    'TESSELLATION GRID', 'COSMIC WEB', 'DIGITAL RAIN', 'PHOTON STREAM', 'REALITY MESH',
                    'SPACETIME FABRIC', 'QUANTUM TUNNEL', 'STELLAR NURSERY', 'GRAVITATIONAL LENS', 'DARK MATTER',
                    'TEMPORAL FLUX', 'DIMENSIONAL RIFT', 'EXOTIC MATTER', 'VACUUM DECAY', 'FIELD EQUATIONS',
                    'HIGGS FIELD', 'STRING THEORY', 'MULTIVERSE', 'CONSCIOUSNESS', 'EMERGENCE'
                ];
                
                this.initialize();
            }
            
            initialize() {
                console.log('üé® Initializing Holographic Cycling System...');
                
                this.createVisualizers();
                this.setupInteractions();
                this.updateVariantDisplay();
                this.startRenderLoop();
            }
            
            createVisualizers() {
                // Create the 5 visualizers using EXACT tech-layout configuration
                const layers = [
                    { id: 'background-canvas', role: 'background', reactivity: 0.5 },
                    { id: 'shadow-canvas', role: 'shadow', reactivity: 0.7 },
                    { id: 'content-canvas', role: 'content', reactivity: 0.9 }, // EXACT workspace card content
                    { id: 'highlight-canvas', role: 'highlight', reactivity: 1.1 }, // EXACT workspace card highlight
                    { id: 'accent-canvas', role: 'accent', reactivity: 1.5 } // ESSENTIAL translucent overlay
                ];
                
                layers.forEach(layer => {
                    // Use the COMPLETE holographic visualizer from our extracted system
                    const visualizer = new CompleteHolographicVisualizer(layer.id, layer.role, layer.reactivity, this.currentVariant);
                    this.visualizers.push(visualizer);
                });
                
                console.log(`‚úÖ Created 5-layer COMPLETE holographic system with tech-layout extraction ready for 30 variations`);
            }
            
            updateVariant(newVariant) {
                if (newVariant < 0) newVariant = this.totalVariants - 1;
                if (newVariant >= this.totalVariants) newVariant = 0;
                
                this.currentVariant = newVariant;
                
                // Update all visualizers with new variant parameters
                this.visualizers.forEach(visualizer => {
                    visualizer.variant = this.currentVariant;
                    visualizer.variantParams = visualizer.generateVariantParams(this.currentVariant);
                    
                    // Completely regenerate role parameters with new variant values
                    const role = visualizer.role;
                    const vp = visualizer.variantParams;
                    
                    visualizer.roleParams = {
                        'background': { 
                            densityMult: 0.4, speedMult: 0.2, colorShift: 0.0, intensity: 0.2,
                            mouseReactivity: 0.3, clickReactivity: 0.1 
                        },
                        'shadow': { 
                            densityMult: 0.8, speedMult: 0.3, colorShift: 180.0, intensity: 0.4,
                            mouseReactivity: 0.5, clickReactivity: 0.3 
                        },
                        'content': { 
                            densityMult: vp.density, speedMult: vp.speed, 
                            colorShift: vp.hue, intensity: vp.intensity,
                            mouseReactivity: 1.0, clickReactivity: 0.8 
                        },
                        'highlight': { 
                            densityMult: 1.5 + (vp.density * 0.3), speedMult: 0.8 + (vp.speed * 0.2), 
                            colorShift: vp.hue + 60.0, intensity: 0.6 + (vp.intensity * 0.2),
                            mouseReactivity: 1.2, clickReactivity: 1.0 
                        },
                        'accent': { 
                            densityMult: 2.5 + (vp.density * 0.5), speedMult: 0.4 + (vp.speed * 0.1), 
                            colorShift: vp.hue + 300.0, intensity: 0.3 + (vp.intensity * 0.1),
                            mouseReactivity: 1.5, clickReactivity: 1.2 
                        }
                    }[role] || { densityMult: 1.0, speedMult: 0.5, colorShift: 0.0, intensity: 0.5, mouseReactivity: 1.0, clickReactivity: 0.5 };
                });
                
                this.updateVariantDisplay();
                console.log(`üîÑ Switched to variant ${this.currentVariant + 1}: ${this.variantNames[this.currentVariant]}`);
                console.log(`üìä Variant params:`, this.visualizers[2].variantParams); // Log content layer params
            }
            
            updateVariantDisplay() {
                const variantNumber = document.getElementById('variantNumber');
                const variantName = document.getElementById('variantName');
                
                variantNumber.textContent = String(this.currentVariant + 1).padStart(2, '0');
                
                // Get the geometry name from the variant parameters
                const geometryName = this.visualizers[0]?.variantParams?.name || this.variantNames[this.currentVariant];
                variantName.textContent = geometryName;
            }
            
            nextVariant() {
                this.updateVariant(this.currentVariant + 1);
            }
            
            previousVariant() {
                this.updateVariant(this.currentVariant - 1);
            }
            
            randomVariant() {
                const randomIndex = Math.floor(Math.random() * this.totalVariants);
                this.updateVariant(randomIndex);
            }
            
            toggleAutoCycle() {
                this.autoCycleActive = !this.autoCycleActive;
                const btn = document.getElementById('autoCycleBtn');
                const status = document.getElementById('autoCycleStatus');
                
                if (this.autoCycleActive) {
                    btn.textContent = '‚è∏ AUTO';
                    status.textContent = 'Auto-cycle: ON (3s)';
                    this.autoCycleInterval = setInterval(() => {
                        this.nextVariant();
                    }, 3000);
                } else {
                    btn.textContent = '‚ñ∂ AUTO';
                    status.textContent = 'Auto-cycle: OFF';
                    if (this.autoCycleInterval) {
                        clearInterval(this.autoCycleInterval);
                        this.autoCycleInterval = null;
                    }
                }
            }
            
            setupInteractions() {
                // Mouse tracking system
                document.addEventListener('mousemove', (e) => {
                    this.mouseX = e.clientX / window.innerWidth;
                    this.mouseY = 1.0 - (e.clientY / window.innerHeight);
                    this.mouseIntensity = Math.min(1.0, Math.sqrt(e.movementX*e.movementX + e.movementY*e.movementY) / 40);
                    
                    // Update all visualizers
                    this.visualizers.forEach(visualizer => {
                        visualizer.updateInteraction(this.mouseX, this.mouseY, this.mouseIntensity);
                    });
                    
                    // Grid overlay activation
                    const gridOverlay = document.getElementById('gridOverlay');
                    if (this.mouseIntensity > 0.3) {
                        gridOverlay.classList.add('active');
                    } else {
                        gridOverlay.classList.remove('active');
                    }
                    
                    // Density variation
                    const densityVar = Math.sin(this.mouseX * Math.PI) * Math.sin(this.mouseY * Math.PI) * 2.0;
                    this.visualizers.forEach(visualizer => {
                        visualizer.updateDensity(densityVar);
                    });
                });
                
                // Click interactions
                document.addEventListener('click', (e) => {
                    const rect = document.body.getBoundingClientRect();
                    const clickX = (e.clientX - rect.left) / rect.width;
                    const clickY = 1.0 - ((e.clientY - rect.top) / rect.height);
                    
                    // Trigger click effect on all visualizers
                    this.visualizers.forEach(visualizer => {
                        visualizer.triggerClick(clickX, clickY);
                    });
                    
                    // Create ripple effect
                    this.createRipple(e.clientX, e.clientY);
                });
                
                // ENHANCED TOUCH INTERACTION SYSTEM
                let currentTouch = null;
                let touchStartTime = 0;
                
                // Only apply touch effects to the holographic display area, not UI controls
                const holographicDisplay = document.getElementById('holographicDisplay');
                
                const isOverHolographicArea = (e) => {
                    const touch = e.touches[0] || e.changedTouches[0];
                    if (!touch) return false;
                    
                    const element = document.elementFromPoint(touch.clientX, touch.clientY);
                    if (!element) return false;
                    
                    // More robust detection - check if it's canvas, holographic display, or grid overlay
                    return element.tagName === 'CANVAS' || 
                           element.id === 'holographicDisplay' ||
                           element.id === 'gridOverlay' ||
                           holographicDisplay.contains(element);
                };
                
                const isOverUIControl = (e) => {
                    const touch = e.touches[0] || e.changedTouches[0];
                    if (!touch) return false;
                    
                    const element = document.elementFromPoint(touch.clientX, touch.clientY);
                    if (!element) return false;
                    
                    // Check if touching UI controls
                    return element.closest('.control-panel') || 
                           element.closest('.control-btn') ||
                           element.classList.contains('control-btn') ||
                           element.classList.contains('control-panel');
                };
                
                document.addEventListener('touchstart', (e) => {
                    // Always allow UI controls to work normally
                    if (isOverUIControl(e)) {
                        return; // Let the UI handle this normally
                    }
                    
                    if (isOverHolographicArea(e) && e.touches.length > 0) {
                        e.preventDefault(); // Only prevent default for holographic area
                        currentTouch = e.touches[0];
                        touchStartTime = Date.now();
                        const touchX = currentTouch.clientX / window.innerWidth;
                        const touchY = 1.0 - (currentTouch.clientY / window.innerHeight);
                        
                        // IMMEDIATE TOUCH FEEDBACK - Trigger click effect instantly
                        this.visualizers.forEach(visualizer => {
                            visualizer.triggerClick(touchX, touchY);
                            visualizer.updateTouch(touchX, touchY, true);
                        });
                        
                        // Create immediate ripple effect
                        this.createRipple(currentTouch.clientX, currentTouch.clientY);
                    }
                }, { passive: false });
                
                document.addEventListener('touchmove', (e) => {
                    // Always allow UI controls to work normally
                    if (isOverUIControl(e)) {
                        return;
                    }
                    
                    if (isOverHolographicArea(e) && e.touches.length > 0 && currentTouch) {
                        e.preventDefault(); // Only prevent default for holographic area
                        const touch = e.touches[0];
                        const touchX = touch.clientX / window.innerWidth;
                        const touchY = 1.0 - (touch.clientY / window.innerHeight);
                        
                        // Update touch morphing during move
                        this.visualizers.forEach(visualizer => {
                            visualizer.updateTouch(touchX, touchY, true);
                        });
                        
                        currentTouch = touch;
                    }
                }, { passive: false });
                
                document.addEventListener('touchend', (e) => {
                    if (currentTouch) {
                        const touchDuration = Date.now() - touchStartTime;
                        
                        // Quick touch (< 150ms) gets extra click intensity
                        if (touchDuration < 150) {
                            this.visualizers.forEach(visualizer => {
                                visualizer.clickIntensity = Math.min(1.0, visualizer.clickIntensity + 0.3);
                            });
                        }
                        
                        // Reset touch state
                        this.visualizers.forEach(visualizer => {
                            visualizer.updateTouch(0.5, 0.5, false);
                        });
                        currentTouch = null;
                    }
                }, { passive: false });
                
                // SELECTIVE SCROLL PARALLAX SYSTEM
                document.addEventListener('wheel', (e) => {
                    // Check if scroll is over UI controls first
                    const element = document.elementFromPoint(e.clientX, e.clientY);
                    const isOverUI = element && (element.closest('.control-panel') || element.closest('.control-btn'));
                    
                    // Only capture scroll when over the holographic display area
                    const isOverHolographic = !isOverUI && (element && (
                        element.tagName === 'CANVAS' ||
                        element.id === 'holographicDisplay' ||
                        element.id === 'gridOverlay' ||
                        holographicDisplay.contains(element)
                    ));
                    
                    if (isOverHolographic) {
                        e.preventDefault(); // Only prevent default for holographic area
                        
                        // Update scroll on all visualizers
                        this.visualizers.forEach(visualizer => {
                            visualizer.updateScroll(e.deltaY);
                        });
                        
                        // Subtle grid overlay response to scroll
                        const gridOverlay = document.getElementById('gridOverlay');
                        gridOverlay.style.transform = `translateY(${e.deltaY * 0.1}px)`;
                        setTimeout(() => {
                            gridOverlay.style.transform = 'translateY(0px)';
                        }, 100);
                    }
                    // Allow normal scrolling behavior for UI controls
                }, { passive: false });
                
                // Keyboard shortcuts
                document.addEventListener('keydown', (e) => {
                    switch(e.key) {
                        case 'ArrowLeft':
                            this.previousVariant();
                            e.preventDefault();
                            break;
                        case 'ArrowRight':
                            this.nextVariant();
                            e.preventDefault();
                            break;
                        case ' ':
                            this.randomVariant();
                            e.preventDefault();
                            break;
                        case 'Enter':
                            this.toggleAutoCycle();
                            e.preventDefault();
                            break;
                    }
                });
            }
            
            createRipple(x, y) {
                const ripple = document.createElement('div');
                ripple.className = 'interaction-ripple';
                ripple.style.left = (x - 50) + 'px';
                ripple.style.top = (y - 50) + 'px';
                document.body.appendChild(ripple);
                
                setTimeout(() => {
                    document.body.removeChild(ripple);
                }, 600);
            }
            
            startRenderLoop() {
                const render = () => {
                    // Render all visualizers
                    this.visualizers.forEach(visualizer => {
                        visualizer.render();
                    });
                    
                    requestAnimationFrame(render);
                };
                
                render();
                console.log('üé¨ Holographic cycling render loop started');
            }
        }
        
        // Global control functions with mobile debugging
        function nextVariant() {
            console.log('üîÑ Next variant clicked');
            if (window.holographicSystem) {
                window.holographicSystem.nextVariant();
            } else {
                console.error('‚ùå holographicSystem not found');
            }
        }
        
        function previousVariant() {
            console.log('üîÑ Previous variant clicked');
            if (window.holographicSystem) {
                window.holographicSystem.previousVariant();
            } else {
                console.error('‚ùå holographicSystem not found');
            }
        }
        
        function randomVariant() {
            console.log('üé≤ Random variant clicked');
            if (window.holographicSystem) {
                window.holographicSystem.randomVariant();
            } else {
                console.error('‚ùå holographicSystem not found');
            }
        }
        
        function toggleAutoCycle() {
            console.log('‚è∏ Auto cycle toggled');
            if (window.holographicSystem) {
                window.holographicSystem.toggleAutoCycle();
            } else {
                console.error('‚ùå holographicSystem not found');
            }
        }
        
        // Initialize when page loads
        window.addEventListener('load', () => {
            console.log('üöÄ Initializing Active Holographic Systems - Cycling Demo...');
            const system = new HolographicCyclingSystem();
            window.holographicSystem = system;
            
            // Add explicit button event listeners for mobile compatibility
            console.log('üì± Setting up mobile button handlers...');
            
            // Find all control buttons and add multiple event types
            const buttons = document.querySelectorAll('.control-btn');
            buttons.forEach((button, index) => {
                const buttonText = button.textContent.trim();
                console.log(`üîò Setting up button: ${buttonText}`);
                
                // Add both click and touchend events
                const handleButtonPress = (e) => {
                    e.stopPropagation();
                    console.log(`üî• Button pressed: ${buttonText}`);
                    
                    if (buttonText.includes('PREV')) {
                        previousVariant();
                    } else if (buttonText.includes('NEXT')) {
                        nextVariant();
                    } else if (buttonText.includes('RANDOM')) {
                        randomVariant();
                    } else if (buttonText.includes('AUTO')) {
                        toggleAutoCycle();
                    }
                };
                
                // Add multiple event types for maximum compatibility
                button.addEventListener('click', handleButtonPress, false);
                button.addEventListener('touchend', handleButtonPress, false);
                button.addEventListener('pointerup', handleButtonPress, false);
            });
            
            console.log('‚úÖ Mobile button handlers setup complete');
        });
        
    </script>
</body>
</html>