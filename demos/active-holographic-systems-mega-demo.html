<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Active Holographic Systems - 30 Variations Mega Demo</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap');
        
        body {
            margin: 0;
            background: #000;
            overflow: hidden;
            font-family: 'Orbitron', 'Courier New', monospace;
            height: 100vh;
            cursor: crosshair;
            background: radial-gradient(ellipse at center, #1a0033 0%, #000000 70%);
        }
        
        /* SINGLE HOLOGRAPHIC DISPLAY */
        .holographic-display {
            position: absolute;
            top: 10%;
            left: 10%;
            width: 80%;
            height: 80%;
            border-radius: 25px;
            overflow: hidden;
            transition: all 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            transform-style: preserve-3d;
            
            /* Neoskeuomorphic shadow system */
            box-shadow: 
                0 20px 40px rgba(0, 0, 0, 0.4),
                0 8px 16px rgba(0, 0, 0, 0.3),
                inset 0 2px 4px rgba(255, 255, 255, 0.1),
                inset 0 -2px 2px rgba(0, 0, 0, 0.1),
                0 0 0 2px rgba(0, 255, 255, 0.3),
                0 0 30px rgba(0, 255, 255, 0.2);
        }
        
        .holographic-display:hover {
            transform: scale(1.02) translateZ(10px);
            box-shadow: 
                0 30px 60px rgba(0, 0, 0, 0.5),
                0 12px 24px rgba(0, 0, 0, 0.4),
                inset 0 3px 6px rgba(255, 255, 255, 0.15),
                inset 0 -3px 3px rgba(0, 0, 0, 0.15),
                0 0 0 3px rgba(0, 255, 255, 0.5),
                0 0 50px rgba(0, 255, 255, 0.3);
        }
        
        /* CONTROL PANEL */
        .control-panel {
            position: fixed;
            top: 30px;
            right: 30px;
            background: linear-gradient(135deg,
                rgba(0, 0, 0, 0.9) 0%,
                rgba(25, 0, 50, 0.8) 100%
            );
            padding: 20px;
            border-radius: 15px;
            border: 1px solid #00ffff;
            font-family: 'Orbitron', monospace;
            z-index: 2000;
            backdrop-filter: blur(25px);
            box-shadow: 
                0 10px 30px rgba(0, 0, 0, 0.6),
                inset 0 1px 1px rgba(255, 255, 255, 0.1),
                0 0 0 1px rgba(0, 255, 255, 0.2);
        }
        
        .variant-display {
            text-align: center;
            margin-bottom: 15px;
            color: #00ffff;
            font-size: 0.9rem;
        }
        
        .variant-number {
            font-size: 1.8rem;
            font-weight: bold;
            color: #ffffff;
            text-shadow: 0 0 10px rgba(0, 255, 255, 0.8);
        }
        
        .control-buttons {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }
        
        .control-btn {
            background: rgba(0, 255, 255, 0.2);
            border: 1px solid #00ffff;
            color: #00ffff;
            padding: 8px 16px;
            border-radius: 8px;
            cursor: pointer;
            font-family: 'Orbitron', monospace;
            font-size: 0.8rem;
            transition: all 0.3s ease;
        }
        
        .control-btn:hover {
            background: rgba(0, 255, 255, 0.4);
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.5);
            transform: translateY(-2px);
        }
        
        .control-btn:active {
            transform: translateY(0);
        }
        
        .auto-cycle {
            margin-top: 10px;
            font-size: 0.7rem;
            color: rgba(255, 255, 255, 0.7);
            text-align: center;
        }
        
        /* HOLOGRAPHIC CANVAS LAYERS */
        canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        
        /* EXPANDED VIEW */
        .expanded-view {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0, 0, 0, 0.95);
            z-index: 1000;
            display: none;
            backdrop-filter: blur(10px);
        }
        
        .expanded-view.active {
            display: block;
        }
        
        .expanded-card {
            position: absolute;
            top: 10%;
            left: 10%;
            width: 80%;
            height: 80%;
            border-radius: 25px;
            overflow: hidden;
            box-shadow: 
                0 30px 60px rgba(0, 0, 0, 0.8),
                inset 0 2px 4px rgba(255, 255, 255, 0.1),
                0 0 0 2px rgba(0, 255, 255, 0.4),
                0 0 40px rgba(0, 255, 255, 0.3);
        }
        
        .close-button {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 255, 255, 0.2);
            border: 1px solid #00ffff;
            color: #00ffff;
            padding: 12px 20px;
            border-radius: 10px;
            cursor: pointer;
            font-family: 'Orbitron', monospace;
            font-size: 0.9rem;
            z-index: 1001;
            transition: all 0.3s ease;
        }
        
        .close-button:hover {
            background: rgba(0, 255, 255, 0.4);
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.5);
        }
        
        /* GRID OVERLAY SYSTEM */
        .grid-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 20;
            opacity: 0.1;
            transition: opacity 0.3s ease;
            background: 
                repeating-linear-gradient(0deg, transparent, transparent 20px, rgba(0, 255, 255, 0.1) 20px, rgba(0, 255, 255, 0.1) 21px),
                repeating-linear-gradient(90deg, transparent, transparent 20px, rgba(0, 255, 255, 0.1) 20px, rgba(0, 255, 255, 0.1) 21px);
        }
        
        .grid-overlay.active {
            opacity: 0.3;
        }
        
        /* INTERACTION RIPPLE */
        .interaction-ripple {
            position: absolute;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(0, 255, 255, 0.6) 0%, transparent 70%);
            pointer-events: none;
            z-index: 30;
            animation: rippleExpand 0.6s ease-out forwards;
        }
        
        @keyframes rippleExpand {
            0% { width: 0; height: 0; opacity: 1; }
            100% { width: 100px; height: 100px; opacity: 0; }
        }
    </style>
</head>
<body>
    <!-- GRID OVERLAY -->
    <div class="grid-overlay" id="gridOverlay"></div>
    
    <!-- CONTROL PANEL -->
    <div class="control-panel">
        <div class="variant-display">
            <div>HOLOGRAPHIC VARIANT</div>
            <div class="variant-number" id="variantNumber">01</div>
            <div id="variantName">HYPERCUBE LATTICE</div>
        </div>
        <div class="control-buttons">
            <button class="control-btn" onclick="previousVariant()">‚óÄ PREV</button>
            <button class="control-btn" onclick="nextVariant()">NEXT ‚ñ∂</button>
        </div>
        <div class="control-buttons">
            <button class="control-btn" onclick="randomVariant()">üé≤ RANDOM</button>
            <button class="control-btn" onclick="toggleAutoCycle()" id="autoCycleBtn">‚è∏ AUTO</button>
        </div>
        <div class="auto-cycle" id="autoCycleStatus">Auto-cycle: OFF</div>
    </div>
    
    <!-- SINGLE HOLOGRAPHIC DISPLAY -->
    <div class="holographic-display" id="holographicDisplay">
        <!-- 5-layer holographic system -->
        <canvas id="background-canvas" style="z-index: 1; opacity: 0.2;"></canvas>
        <canvas id="shadow-canvas" style="z-index: 3; opacity: 0.6; filter: blur(2px) brightness(0.7); mix-blend-mode: multiply; transform: translate(2px, 2px);"></canvas>
        <canvas id="content-canvas" style="z-index: 5; opacity: 0.8; mix-blend-mode: normal;"></canvas>
        <canvas id="highlight-canvas" style="z-index: 7; opacity: 0.4; filter: blur(1px) brightness(1.5); mix-blend-mode: screen; transform: translate(-1px, -1px);"></canvas>
        <canvas id="accent-canvas" style="z-index: 15; opacity: 0.3; filter: blur(2px); mix-blend-mode: color-dodge; transform: scale(1.01);"></canvas>
    </div>

    <script>
        console.log('üåå Active Holographic Systems - 30 Variations Mega Demo');
        
        // COMPLETE HOLOGRAPHIC VISUALIZER WITH FULL REACTIVITY
        class CompleteHolographicVisualizer {
            constructor(canvasId, role = 'content', reactivity = 1.0, variant = 0) {
                this.canvas = document.getElementById(canvasId);
                this.role = role;
                this.reactivity = reactivity;
                this.variant = variant;
                this.gl = this.canvas.getContext('webgl');
                
                if (!this.gl) {
                    console.error(`WebGL not supported for ${canvasId}`);
                    return;
                }
                
                // VARIATION-SPECIFIC PARAMETERS
                this.variantParams = this.generateVariantParams(variant);
                
                // EXACT role-specific parameters from tech-layout with variant customization
                this.roleParams = {
                    'background': { 
                        densityMult: 0.4, speedMult: 0.2, colorShift: 0.0, intensity: 0.2,
                        mouseReactivity: 0.3, clickReactivity: 0.1 
                    },
                    'shadow': { 
                        densityMult: 0.8, speedMult: 0.3, colorShift: 180.0, intensity: 0.4,
                        mouseReactivity: 0.5, clickReactivity: 0.3 
                    },
                    'content': { 
                        densityMult: this.variantParams.density, speedMult: this.variantParams.speed, 
                        colorShift: this.variantParams.hue, intensity: this.variantParams.intensity,
                        mouseReactivity: 1.0, clickReactivity: 0.8 
                    },
                    'highlight': { 
                        densityMult: 1.5 + (this.variantParams.density * 0.3), speedMult: 0.8 + (this.variantParams.speed * 0.2), 
                        colorShift: this.variantParams.hue + 60.0, intensity: 0.6 + (this.variantParams.intensity * 0.2),
                        mouseReactivity: 1.2, clickReactivity: 1.0 
                    },
                    'accent': { 
                        densityMult: 2.5 + (this.variantParams.density * 0.5), speedMult: 0.4 + (this.variantParams.speed * 0.1), 
                        colorShift: this.variantParams.hue + 300.0, intensity: 0.3 + (this.variantParams.intensity * 0.1),
                        mouseReactivity: 1.5, clickReactivity: 1.2 
                    }
                }[role] || { densityMult: 1.0, speedMult: 0.5, colorShift: 0.0, intensity: 0.5, mouseReactivity: 1.0, clickReactivity: 0.5 };
                
                // EXACT state system from tech-layout
                this.currentState = 1; // TECH
                this.targetState = 1;
                this.transitionProgress = 1.0;
                this.chaosIntensity = 0.0;
                
                // EXACT mouse interaction system
                this.mouseX = 0.5;
                this.mouseY = 0.5;
                this.mouseIntensity = 0.0;
                this.clickIntensity = 0.0;
                this.clickDecay = 0.95;
                
                // EXACT density system with variations
                this.baseDensity = 6.0 + Math.random() * 4.0;
                this.densityVariation = 0.0;
                this.densityTarget = 0.0;
                
                this.startTime = Date.now();
                this.initShaders();
                this.initBuffers();
                this.resize();
            }
            
            generateVariantParams(variant) {
                // Define 30 distinct 4D geometric systems and behaviors
                const geometryTypes = [
                    // 0-4: Lattice Systems
                    { type: 'tetrahedron', name: 'HYPERCUBE LATTICE' },
                    { type: 'octahedron', name: 'PLASMA FIELD' },
                    { type: 'icosahedron', name: 'CRYSTAL MATRIX' },
                    { type: 'dodecahedron', name: 'NEURAL NETWORK' },
                    { type: 'hexagonal', name: 'QUANTUM FOAM' },
                    
                    // 5-9: Wave Systems
                    { type: 'sinewave', name: 'FRACTAL DIMENSION' },
                    { type: 'spiralwave', name: 'HOLOGRAPHIC CORE' },
                    { type: 'shockwave', name: 'ENERGY VORTEX' },
                    { type: 'interference', name: 'PARTICLE STORM' },
                    { type: 'standing', name: 'WAVE FUNCTION' },
                    
                    // 10-14: Organic Systems
                    { type: 'voronoi', name: 'TESSELLATION GRID' },
                    { type: 'perlin', name: 'COSMIC WEB' },
                    { type: 'cellular', name: 'DIGITAL RAIN' },
                    { type: 'fractal', name: 'PHOTON STREAM' },
                    { type: 'mandelbrot', name: 'REALITY MESH' },
                    
                    // 15-19: Physics Systems
                    { type: 'spacetime', name: 'SPACETIME FABRIC' },
                    { type: 'blackhole', name: 'QUANTUM TUNNEL' },
                    { type: 'pulsar', name: 'STELLAR NURSERY' },
                    { type: 'gravity', name: 'GRAVITATIONAL LENS' },
                    { type: 'antimatter', name: 'DARK MATTER' },
                    
                    // 20-24: Quantum Systems
                    { type: 'superposition', name: 'TEMPORAL FLUX' },
                    { type: 'entanglement', name: 'DIMENSIONAL RIFT' },
                    { type: 'uncertainty', name: 'EXOTIC MATTER' },
                    { type: 'collapse', name: 'VACUUM DECAY' },
                    { type: 'field', name: 'FIELD EQUATIONS' },
                    
                    // 25-29: Advanced Systems
                    { type: 'higgs', name: 'HIGGS FIELD' },
                    { type: 'string', name: 'STRING THEORY' },
                    { type: 'brane', name: 'MULTIVERSE' },
                    { type: 'consciousness', name: 'CONSCIOUSNESS' },
                    { type: 'emergence', name: 'EMERGENCE' }
                ];
                
                const currentGeometry = geometryTypes[variant % 30];
                const seed = variant / 30.0;
                
                // Base parameters that vary per geometry type
                let base = {
                    geometryType: currentGeometry.type,
                    name: currentGeometry.name,
                    density: 1.0,
                    speed: 0.5,
                    hue: (variant * 12.27) % 360,
                    intensity: 0.7,
                    chaos: 0.0,
                    morph: 0.0
                };
                
                // Customize parameters based on geometry type
                switch(currentGeometry.type) {
                    case 'tetrahedron':
                        base = { ...base, density: 0.8, speed: 0.3, chaos: 0.0, morph: 0.0 };
                        break;
                    case 'octahedron':
                        base = { ...base, density: 1.2, speed: 0.4, chaos: 0.1, morph: 0.3 };
                        break;
                    case 'icosahedron':
                        base = { ...base, density: 1.6, speed: 0.2, chaos: 0.0, morph: 0.8 };
                        break;
                    case 'dodecahedron':
                        base = { ...base, density: 2.0, speed: 0.6, chaos: 0.2, morph: 0.5 };
                        break;
                    case 'hexagonal':
                        base = { ...base, density: 1.4, speed: 0.8, chaos: 0.3, morph: 0.2 };
                        break;
                    case 'sinewave':
                        base = { ...base, density: 0.6, speed: 1.0, chaos: 0.4, morph: 0.9 };
                        break;
                    case 'spiralwave':
                        base = { ...base, density: 0.9, speed: 1.2, chaos: 0.1, morph: 1.0 };
                        break;
                    case 'shockwave':
                        base = { ...base, density: 0.4, speed: 1.8, chaos: 0.6, morph: 0.3 };
                        break;
                    case 'interference':
                        base = { ...base, density: 1.8, speed: 0.7, chaos: 0.8, morph: 0.4 };
                        break;
                    case 'standing':
                        base = { ...base, density: 1.0, speed: 0.1, chaos: 0.0, morph: 0.7 };
                        break;
                    case 'voronoi':
                        base = { ...base, density: 1.3, speed: 0.4, chaos: 0.3, morph: 0.6 };
                        break;
                    case 'perlin':
                        base = { ...base, density: 0.7, speed: 0.3, chaos: 0.5, morph: 0.8 };
                        break;
                    case 'cellular':
                        base = { ...base, density: 2.2, speed: 0.9, chaos: 0.2, morph: 0.1 };
                        break;
                    case 'fractal':
                        base = { ...base, density: 1.5, speed: 0.5, chaos: 0.7, morph: 0.9 };
                        break;
                    case 'mandelbrot':
                        base = { ...base, density: 0.8, speed: 0.2, chaos: 0.9, morph: 0.5 };
                        break;
                    case 'spacetime':
                        base = { ...base, density: 0.5, speed: 0.6, chaos: 0.4, morph: 0.8 };
                        break;
                    case 'blackhole':
                        base = { ...base, density: 3.0, speed: 0.1, chaos: 0.1, morph: 0.2 };
                        break;
                    case 'pulsar':
                        base = { ...base, density: 0.3, speed: 2.0, chaos: 0.0, morph: 0.1 };
                        break;
                    case 'gravity':
                        base = { ...base, density: 1.1, speed: 0.4, chaos: 0.2, morph: 0.6 };
                        break;
                    case 'antimatter':
                        base = { ...base, density: 0.9, speed: 0.8, chaos: 0.6, morph: 0.4 };
                        break;
                    case 'superposition':
                        base = { ...base, density: 1.7, speed: 1.1, chaos: 0.9, morph: 0.7 };
                        break;
                    case 'entanglement':
                        base = { ...base, density: 2.1, speed: 0.7, chaos: 0.3, morph: 0.8 };
                        break;
                    case 'uncertainty':
                        base = { ...base, density: 0.6, speed: 1.5, chaos: 1.0, morph: 0.9 };
                        break;
                    case 'collapse':
                        base = { ...base, density: 2.5, speed: 0.3, chaos: 0.1, morph: 0.0 };
                        break;
                    case 'field':
                        base = { ...base, density: 1.2, speed: 0.9, chaos: 0.2, morph: 0.5 };
                        break;
                    case 'higgs':
                        base = { ...base, density: 0.4, speed: 0.5, chaos: 0.4, morph: 0.6 };
                        break;
                    case 'string':
                        base = { ...base, density: 0.2, speed: 1.3, chaos: 0.1, morph: 1.0 };
                        break;
                    case 'brane':
                        base = { ...base, density: 1.6, speed: 0.6, chaos: 0.5, morph: 0.3 };
                        break;
                    case 'consciousness':
                        base = { ...base, density: 0.8, speed: 1.4, chaos: 0.8, morph: 0.7 };
                        break;
                    case 'emergence':
                        base = { ...base, density: 1.9, speed: 0.8, chaos: 0.6, morph: 0.8 };
                        break;
                }
                
                return base;
            }
            
            initShaders() {
                const vertexShaderSource = `
                    attribute vec2 a_position;
                    void main() {
                        gl_Position = vec4(a_position, 0.0, 1.0);
                    }
                `;
                
                const fragmentShaderSource = `
                    precision highp float;
                    
                    uniform vec2 u_resolution;
                    uniform float u_time;
                    uniform vec2 u_mouse;
                    uniform float u_geometry;
                    uniform float u_density;
                    uniform float u_speed;
                    uniform vec3 u_color;
                    uniform float u_intensity;
                    uniform float u_roleDensity;
                    uniform float u_roleSpeed;
                    uniform float u_colorShift;
                    uniform float u_chaosIntensity;
                    uniform float u_mouseIntensity;
                    uniform float u_clickIntensity;
                    uniform float u_densityVariation;
                    uniform float u_geometryType;
                    uniform float u_chaos;
                    uniform float u_morph;
                    
                    // EXACT 4D rotation matrices from tech-layout
                    mat4 rotateXW(float theta) {
                        float c = cos(theta);
                        float s = sin(theta);
                        return mat4(c, 0, 0, -s, 0, 1, 0, 0, 0, 0, 1, 0, s, 0, 0, c);
                    }
                    
                    mat4 rotateYW(float theta) {
                        float c = cos(theta);
                        float s = sin(theta);
                        return mat4(1, 0, 0, 0, 0, c, 0, -s, 0, 0, 1, 0, 0, s, 0, c);
                    }
                    
                    mat4 rotateZW(float theta) {
                        float c = cos(theta);
                        float s = sin(theta);
                        return mat4(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, c, -s, 0, 0, s, c);
                    }
                    
                    // EXACT 4D to 3D projection from tech-layout
                    vec3 project4Dto3D(vec4 p) {
                        float w = 2.5 / (2.5 + p.w);
                        return vec3(p.x * w, p.y * w, p.z * w);
                    }
                    
                    // EXACT tetrahedron lattice from tech-layout
                    float tetrahedronLattice(vec3 p, float gridSize) {
                        vec3 q = fract(p * gridSize) - 0.5;
                        
                        // Tetrahedron vertices
                        float d1 = length(q);
                        float d2 = length(q - vec3(0.4, 0.0, 0.0));
                        float d3 = length(q - vec3(0.0, 0.4, 0.0));
                        float d4 = length(q - vec3(0.0, 0.0, 0.4));
                        
                        float vertices = 1.0 - smoothstep(0.0, 0.04, min(min(d1, d2), min(d3, d4)));
                        
                        // Edge connections
                        float edges = 0.0;
                        edges = max(edges, 1.0 - smoothstep(0.0, 0.02, abs(length(q.xy) - 0.2)));
                        edges = max(edges, 1.0 - smoothstep(0.0, 0.02, abs(length(q.yz) - 0.2)));
                        edges = max(edges, 1.0 - smoothstep(0.0, 0.02, abs(length(q.xz) - 0.2)));
                        
                        return max(vertices, edges * 0.5);
                    }
                    
                    // OCTAHEDRON LATTICE - 8 faces, more angular
                    float octahedronLattice(vec3 p, float gridSize) {
                        vec3 q = fract(p * gridSize) - 0.5;
                        float d = abs(q.x) + abs(q.y) + abs(q.z);
                        return 1.0 - smoothstep(0.3, 0.35, d);
                    }
                    
                    // ICOSAHEDRON LATTICE - 20 faces, complex geometry
                    float icosahedronLattice(vec3 p, float gridSize) {
                        vec3 q = fract(p * gridSize) - 0.5;
                        float phi = (1.0 + sqrt(5.0)) / 2.0; // Golden ratio
                        vec3 ice1 = vec3(1.0, phi, 0.0) / 2.0;
                        vec3 ice2 = vec3(0.0, 1.0, phi) / 2.0;
                        vec3 ice3 = vec3(phi, 0.0, 1.0) / 2.0;
                        
                        float d1 = min(length(q - ice1), length(q + ice1));
                        float d2 = min(length(q - ice2), length(q + ice2));
                        float d3 = min(length(q - ice3), length(q + ice3));
                        
                        return 1.0 - smoothstep(0.0, 0.06, min(min(d1, d2), d3));
                    }
                    
                    // DODECAHEDRON LATTICE - 12 pentagonal faces
                    float dodecahedronLattice(vec3 p, float gridSize) {
                        vec3 q = fract(p * gridSize) - 0.5;
                        float phi = (1.0 + sqrt(5.0)) / 2.0;
                        
                        // Pentagon-based structure
                        float angle = atan(q.y, q.x);
                        float r = length(q.xy);
                        float pentagon = cos(angle * 5.0) * 0.1;
                        
                        return 1.0 - smoothstep(0.15 + pentagon, 0.25 + pentagon, r + abs(q.z) * 0.5);
                    }
                    
                    // HEXAGONAL LATTICE - honeycomb structure
                    float hexagonalLattice(vec3 p, float gridSize) {
                        vec3 q = fract(p * gridSize) - 0.5;
                        
                        // Hexagonal tiling
                        float angle = atan(q.y, q.x);
                        float r = length(q.xy);
                        float hex = cos(angle * 6.0) * 0.05;
                        
                        return 1.0 - smoothstep(0.2 + hex, 0.25 + hex, r);
                    }
                    
                    // SINE WAVE PATTERNS - undulating fields
                    float sinewaveLattice(vec3 p, float gridSize) {
                        vec3 q = p * gridSize;
                        float wave1 = sin(q.x * 2.0) * sin(q.y * 2.0) * sin(q.z * 2.0);
                        float wave2 = sin(q.x * 3.0 + u_time * 0.001) * 0.5;
                        return (wave1 + wave2 + 1.0) * 0.5;
                    }
                    
                    // SPIRAL WAVE - rotating helical structure
                    float spiralwaveLattice(vec3 p, float gridSize) {
                        vec3 q = p * gridSize;
                        float r = length(q.xy);
                        float angle = atan(q.y, q.x);
                        float spiral = sin(r * 8.0 - angle * 4.0 + u_time * 0.002);
                        float height = sin(q.z * 4.0 + u_time * 0.001);
                        return (spiral * height + 1.0) * 0.5;
                    }
                    
                    // SHOCK WAVE - expanding rings
                    float shockwaveLattice(vec3 p, float gridSize) {
                        vec3 q = p * gridSize;
                        float dist = length(q);
                        float shock = sin(dist * 6.0 - u_time * 0.003) * exp(-dist * 0.5);
                        return (shock + 1.0) * 0.5;
                    }
                    
                    // INTERFERENCE PATTERN - wave interference
                    float interferenceLattice(vec3 p, float gridSize) {
                        vec3 q = p * gridSize;
                        float wave1 = sin(length(q - vec3(1.0, 0.0, 0.0)) * 8.0 - u_time * 0.002);
                        float wave2 = sin(length(q - vec3(-1.0, 0.0, 0.0)) * 8.0 - u_time * 0.002);
                        float wave3 = sin(length(q - vec3(0.0, 1.0, 0.0)) * 8.0 - u_time * 0.002);
                        return (wave1 + wave2 + wave3 + 3.0) * 0.25;
                    }
                    
                    // STANDING WAVE - stationary oscillation
                    float standingLattice(vec3 p, float gridSize) {
                        vec3 q = p * gridSize;
                        float standing = sin(q.x * 4.0) * sin(q.y * 4.0) * sin(q.z * 4.0) * cos(u_time * 0.001);
                        return (standing + 1.0) * 0.5;
                    }
                    
                    // VORONOI NOISE - cellular structure
                    float voronoiLattice(vec3 p, float gridSize) {
                        vec3 q = p * gridSize;
                        vec3 i = floor(q);
                        vec3 f = fract(q);
                        
                        float minDist = 1.0;
                        for(int x = -1; x <= 1; x++) {
                            for(int y = -1; y <= 1; y++) {
                                for(int z = -1; z <= 1; z++) {
                                    vec3 neighbor = vec3(float(x), float(y), float(z));
                                    vec3 point = 0.5 + 0.5 * sin(6.2831 * (i + neighbor + u_time * 0.0005));
                                    vec3 diff = neighbor + point - f;
                                    float dist = length(diff);
                                    minDist = min(minDist, dist);
                                }
                            }
                        }
                        return 1.0 - minDist;
                    }
                    
                    // PERLIN NOISE - organic flowing patterns
                    float perlinLattice(vec3 p, float gridSize) {
                        vec3 q = p * gridSize;
                        // Simplified Perlin-like noise
                        float noise = sin(q.x) * sin(q.y) * sin(q.z);
                        noise += sin(q.x * 2.0) * sin(q.y * 2.0) * sin(q.z * 2.0) * 0.5;
                        noise += sin(q.x * 4.0) * sin(q.y * 4.0) * sin(q.z * 4.0) * 0.25;
                        return (noise + 1.0) * 0.5;
                    }
                    
                    // CELLULAR AUTOMATA - digital life patterns
                    float cellularLattice(vec3 p, float gridSize) {
                        vec3 q = floor(p * gridSize) / gridSize;
                        float cell = step(0.5, sin(q.x * 100.0) * sin(q.y * 100.0) * sin(q.z * 100.0 + u_time * 0.001));
                        return cell;
                    }
                    
                    // FRACTAL GEOMETRY - self-similar patterns
                    float fractalLattice(vec3 p, float gridSize) {
                        vec3 q = p * gridSize;
                        float fractal = 0.0;
                        float amplitude = 1.0;
                        
                        for(int i = 0; i < 4; i++) {
                            fractal += sin(length(q) * amplitude + u_time * 0.001) / amplitude;
                            q *= 2.0;
                            amplitude *= 2.0;
                        }
                        
                        return (fractal + 1.0) * 0.5;
                    }
                    
                    // MANDELBROT-INSPIRED - complex number iteration
                    float mandelbrotLattice(vec3 p, float gridSize) {
                        vec2 c = p.xy * gridSize;
                        vec2 z = vec2(0.0);
                        
                        for(int i = 0; i < 8; i++) {
                            z = vec2(z.x*z.x - z.y*z.y, 2.0*z.x*z.y) + c;
                            if(length(z) > 2.0) break;
                        }
                        
                        return 1.0 - smoothstep(1.5, 2.0, length(z));
                    }
                    
                    // SPACETIME CURVATURE - gravitational field visualization
                    float spacetimeLattice(vec3 p, float gridSize) {
                        vec3 q = p * gridSize;
                        float curvature = 1.0 / (1.0 + length(q) * 2.0);
                        float ripple = sin(length(q) * 4.0 - u_time * 0.002) * curvature;
                        return (ripple + curvature) * 0.5;
                    }
                    
                    // BLACK HOLE - event horizon distortion
                    float blackholeLattice(vec3 p, float gridSize) {
                        vec3 q = p * gridSize;
                        float dist = length(q);
                        float schwarzschild = 1.0 / sqrt(max(0.1, 1.0 - 0.5/dist));
                        float accretion = sin(atan(q.y, q.x) * 8.0 + u_time * 0.004) * exp(-dist);
                        return schwarzschild * accretion;
                    }
                    
                    // PULSAR - rotating neutron star emissions
                    float pulsarLattice(vec3 p, float gridSize) {
                        vec3 q = p * gridSize;
                        float angle = atan(q.y, q.x);
                        float pulse = step(0.8, sin(angle * 2.0 + u_time * 0.01));
                        float beam = exp(-length(q.xy) * 2.0) * pulse;
                        return beam;
                    }
                    
                    // GRAVITATIONAL LENSING - light bending
                    float gravityLattice(vec3 p, float gridSize) {
                        vec3 q = p * gridSize;
                        vec3 lens_pos = vec3(sin(u_time * 0.001), cos(u_time * 0.001), 0.0);
                        float lens_strength = 1.0 / (0.1 + length(q - lens_pos));
                        vec3 deflected = q + (lens_pos - q) * lens_strength * 0.1;
                        return sin(length(deflected) * 6.0) * 0.5 + 0.5;
                    }
                    
                    // ANTIMATTER - particle/antiparticle annihilation
                    float antimatterLattice(vec3 p, float gridSize) {
                        vec3 q = p * gridSize;
                        float matter = sin(length(q + vec3(0.5)) * 8.0);
                        float antimatter = sin(length(q - vec3(0.5)) * 8.0);
                        float annihilation = exp(-abs(matter + antimatter) * 4.0);
                        return annihilation;
                    }
                    
                    // DYNAMIC GEOMETRY SELECTOR
                    float getDynamicGeometry(vec3 p, float gridSize, float geometryType) {
                        if(geometryType < 1.0) return tetrahedronLattice(p, gridSize);
                        else if(geometryType < 2.0) return octahedronLattice(p, gridSize);
                        else if(geometryType < 3.0) return icosahedronLattice(p, gridSize);
                        else if(geometryType < 4.0) return dodecahedronLattice(p, gridSize);
                        else if(geometryType < 5.0) return hexagonalLattice(p, gridSize);
                        else if(geometryType < 6.0) return sinewaveLattice(p, gridSize);
                        else if(geometryType < 7.0) return spiralwaveLattice(p, gridSize);
                        else if(geometryType < 8.0) return shockwaveLattice(p, gridSize);
                        else if(geometryType < 9.0) return interferenceLattice(p, gridSize);
                        else if(geometryType < 10.0) return standingLattice(p, gridSize);
                        else if(geometryType < 11.0) return voronoiLattice(p, gridSize);
                        else if(geometryType < 12.0) return perlinLattice(p, gridSize);
                        else if(geometryType < 13.0) return cellularLattice(p, gridSize);
                        else if(geometryType < 14.0) return fractalLattice(p, gridSize);
                        else if(geometryType < 15.0) return mandelbrotLattice(p, gridSize);
                        else if(geometryType < 16.0) return spacetimeLattice(p, gridSize);
                        else if(geometryType < 17.0) return blackholeLattice(p, gridSize);
                        else if(geometryType < 18.0) return pulsarLattice(p, gridSize);
                        else if(geometryType < 19.0) return gravityLattice(p, gridSize);
                        else if(geometryType < 20.0) return antimatterLattice(p, gridSize);
                        // Quantum systems (20-24) use combinations
                        else if(geometryType < 21.0) return mix(voronoiLattice(p, gridSize), interferenceLattice(p, gridSize), u_morph);
                        else if(geometryType < 22.0) return mix(tetrahedronLattice(p, gridSize * 0.5), tetrahedronLattice(p, gridSize * 2.0), sin(u_time * 0.001));
                        else if(geometryType < 23.0) return fractalLattice(p, gridSize) * (0.5 + 0.5 * sin(u_time * 0.002));
                        else if(geometryType < 24.0) return max(blackholeLattice(p, gridSize), 1.0 - blackholeLattice(p, gridSize));
                        else if(geometryType < 25.0) return perlinLattice(p, gridSize) * sinewaveLattice(p, gridSize);
                        // Advanced systems (25-29) use complex combinations
                        else if(geometryType < 26.0) return mix(spacetimeLattice(p, gridSize), voronoiLattice(p, gridSize), 0.5);
                        else if(geometryType < 27.0) return spiralwaveLattice(p, gridSize * 0.1) * fractalLattice(p, gridSize);
                        else if(geometryType < 28.0) return mix(icosahedronLattice(p, gridSize), dodecahedronLattice(p, gridSize), u_morph);
                        else if(geometryType < 29.0) return perlinLattice(p, gridSize) * interferenceLattice(p, gridSize);
                        else return mix(mix(tetrahedronLattice(p, gridSize), voronoiLattice(p, gridSize), 0.5), fractalLattice(p, gridSize), u_morph);
                    }
                    
                    vec3 hsv2rgb(vec3 c) {
                        vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
                        vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
                        return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
                    }
                    
                    // EXACT holographic effects from tech-layout
                    vec3 rgbGlitch(vec3 color, vec2 uv, float intensity) {
                        vec2 offset = vec2(intensity * 0.005, 0.0);
                        float r = color.r + sin(uv.y * 30.0 + u_time * 0.001) * intensity * 0.06;
                        float g = color.g + sin(uv.y * 28.0 + u_time * 0.0012) * intensity * 0.06;
                        float b = color.b + sin(uv.y * 32.0 + u_time * 0.0008) * intensity * 0.06;
                        return vec3(r, g, b);
                    }
                    
                    float moirePattern(vec2 uv, float intensity) {
                        float freq1 = 12.0 + intensity * 6.0 + u_densityVariation * 3.0;
                        float freq2 = 14.0 + intensity * 8.0 + u_densityVariation * 4.0;
                        float pattern1 = sin(uv.x * freq1) * sin(uv.y * freq1);
                        float pattern2 = sin(uv.x * freq2) * sin(uv.y * freq2);
                        return (pattern1 * pattern2) * intensity * 0.15;
                    }
                    
                    float gridOverlay(vec2 uv, float intensity) {
                        vec2 grid = fract(uv * (8.0 + u_densityVariation * 4.0));
                        float lines = 0.0;
                        lines = max(lines, 1.0 - smoothstep(0.0, 0.02, abs(grid.x - 0.5)));
                        lines = max(lines, 1.0 - smoothstep(0.0, 0.02, abs(grid.y - 0.5)));
                        return lines * intensity * 0.1;
                    }
                    
                    void main() {
                        vec2 uv = gl_FragCoord.xy / u_resolution.xy;
                        float aspectRatio = u_resolution.x / u_resolution.y;
                        uv.x *= aspectRatio;
                        uv -= 0.5;
                        
                        // EXACT 4D space with mouse reactivity from tech-layout
                        float time = u_time * 0.0004 * u_speed * u_roleSpeed;
                        
                        // Mouse influence on rotation
                        float mouseInfluence = u_mouseIntensity * 0.5;
                        vec2 mouseOffset = (u_mouse - 0.5) * mouseInfluence;
                        
                        vec4 p4d = vec4(uv + mouseOffset * 0.1, 
                                       sin(time * 0.1) * 0.15, 
                                       cos(time * 0.08) * 0.15);
                        
                        // EXACT 4D rotations with mouse reactivity from tech-layout
                        p4d = rotateXW(time * 0.2 + mouseOffset.y * 0.5) * p4d;
                        p4d = rotateYW(time * 0.15 + mouseOffset.x * 0.5) * p4d;
                        p4d = rotateZW(time * 0.25 + u_clickIntensity * 0.3) * p4d;
                        
                        vec3 p = project4Dto3D(p4d);
                        
                        // EXACT dynamic density with variation from tech-layout
                        float roleDensity = (u_density + u_densityVariation) * u_roleDensity;
                        
                        // Get dynamic geometry based on variant type
                        float lattice = getDynamicGeometry(p, roleDensity, u_geometryType);
                        
                        // EXACT coloring with mouse reactivity from tech-layout
                        float hue = atan(u_color.r, u_color.g) + u_colorShift * 0.017453 + u_mouseIntensity * 0.2;
                        float saturation = 0.8 + lattice * 0.2 + u_clickIntensity * 0.1;
                        float brightness = 0.2 + lattice * 0.8 + u_intensity * 0.2 + u_mouseIntensity * 0.15;
                        
                        vec3 color = hsv2rgb(vec3(hue, saturation, brightness));
                        
                        // Add EXACT holographic effects from tech-layout
                        color += vec3(moirePattern(uv, u_chaosIntensity));
                        color += vec3(gridOverlay(uv, u_mouseIntensity));
                        color = rgbGlitch(color, uv, u_chaosIntensity);
                        
                        // EXACT mouse interaction glow from tech-layout
                        float mouseDist = length(uv - (u_mouse - 0.5) * vec2(aspectRatio, 1.0));
                        float mouseGlow = exp(-mouseDist * 1.5) * u_mouseIntensity * 0.2;
                        color += vec3(mouseGlow) * u_color * 0.6;
                        
                        // EXACT click pulse effect from tech-layout
                        float clickPulse = u_clickIntensity * exp(-mouseDist * 2.0) * 0.3;
                        color += vec3(clickPulse, clickPulse * 0.5, clickPulse * 1.5);
                        
                        gl_FragColor = vec4(color, 0.95);
                    }
                `;
                
                this.program = this.createProgram(vertexShaderSource, fragmentShaderSource);
                this.uniforms = {
                    resolution: this.gl.getUniformLocation(this.program, 'u_resolution'),
                    time: this.gl.getUniformLocation(this.program, 'u_time'),
                    mouse: this.gl.getUniformLocation(this.program, 'u_mouse'),
                    geometry: this.gl.getUniformLocation(this.program, 'u_geometry'),
                    density: this.gl.getUniformLocation(this.program, 'u_density'),
                    speed: this.gl.getUniformLocation(this.program, 'u_speed'),
                    color: this.gl.getUniformLocation(this.program, 'u_color'),
                    intensity: this.gl.getUniformLocation(this.program, 'u_intensity'),
                    roleDensity: this.gl.getUniformLocation(this.program, 'u_roleDensity'),
                    roleSpeed: this.gl.getUniformLocation(this.program, 'u_roleSpeed'),
                    colorShift: this.gl.getUniformLocation(this.program, 'u_colorShift'),
                    chaosIntensity: this.gl.getUniformLocation(this.program, 'u_chaosIntensity'),
                    mouseIntensity: this.gl.getUniformLocation(this.program, 'u_mouseIntensity'),
                    clickIntensity: this.gl.getUniformLocation(this.program, 'u_clickIntensity'),
                    densityVariation: this.gl.getUniformLocation(this.program, 'u_densityVariation'),
                    geometryType: this.gl.getUniformLocation(this.program, 'u_geometryType'),
                    chaos: this.gl.getUniformLocation(this.program, 'u_chaos'),
                    morph: this.gl.getUniformLocation(this.program, 'u_morph')
                };
            }
            
            createProgram(vertexSource, fragmentSource) {
                const vertexShader = this.createShader(this.gl.VERTEX_SHADER, vertexSource);
                const fragmentShader = this.createShader(this.gl.FRAGMENT_SHADER, fragmentSource);
                
                const program = this.gl.createProgram();
                this.gl.attachShader(program, vertexShader);
                this.gl.attachShader(program, fragmentShader);
                this.gl.linkProgram(program);
                
                if (!this.gl.getProgramParameter(program, this.gl.LINK_STATUS)) {
                    console.error('Program linking failed:', this.gl.getProgramInfoLog(program));
                    return null;
                }
                
                return program;
            }
            
            createShader(type, source) {
                const shader = this.gl.createShader(type);
                this.gl.shaderSource(shader, source);
                this.gl.compileShader(shader);
                
                if (!this.gl.getShaderParameter(shader, this.gl.COMPILE_STATUS)) {
                    console.error('Shader compilation failed:', this.gl.getShaderInfoLog(shader));
                    return null;
                }
                
                return shader;
            }
            
            initBuffers() {
                const positions = new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]);
                
                this.buffer = this.gl.createBuffer();
                this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.buffer);
                this.gl.bufferData(this.gl.ARRAY_BUFFER, positions, this.gl.STATIC_DRAW);
                
                const positionLocation = this.gl.getAttribLocation(this.program, 'a_position');
                this.gl.enableVertexAttribArray(positionLocation);
                this.gl.vertexAttribPointer(positionLocation, 2, this.gl.FLOAT, false, 0, 0);
            }
            
            resize() {
                this.canvas.width = this.canvas.clientWidth;
                this.canvas.height = this.canvas.clientHeight;
                this.gl.viewport(0, 0, this.canvas.width, this.canvas.height);
            }
            
            updateInteraction(mouseX, mouseY, intensity) {
                this.mouseX = mouseX;
                this.mouseY = mouseY;
                this.mouseIntensity = intensity * this.roleParams.mouseReactivity * this.reactivity;
            }
            
            triggerClick(x, y) {
                this.clickIntensity = Math.min(1.0, this.clickIntensity + this.roleParams.clickReactivity * this.reactivity);
            }
            
            updateDensity(variation) {
                this.densityTarget = variation;
            }
            
            render() {
                if (!this.program) return;
                
                this.resize();
                this.gl.useProgram(this.program);
                
                this.densityVariation += (this.densityTarget - this.densityVariation) * 0.05;
                this.clickIntensity *= this.clickDecay;
                
                const time = Date.now() - this.startTime;
                
                // Set uniforms
                this.gl.uniform2f(this.uniforms.resolution, this.canvas.width, this.canvas.height);
                this.gl.uniform1f(this.uniforms.time, time);
                this.gl.uniform2f(this.uniforms.mouse, this.mouseX, this.mouseY);
                this.gl.uniform1f(this.uniforms.geometry, 1.0);
                this.gl.uniform1f(this.uniforms.density, 4.2);
                this.gl.uniform1f(this.uniforms.speed, 0.3);
                this.gl.uniform3fv(this.uniforms.color, new Float32Array([0.0, 1.0, 1.0]));
                this.gl.uniform1f(this.uniforms.intensity, this.roleParams.intensity);
                this.gl.uniform1f(this.uniforms.roleDensity, this.roleParams.densityMult);
                this.gl.uniform1f(this.uniforms.roleSpeed, this.roleParams.speedMult);
                this.gl.uniform1f(this.uniforms.colorShift, this.roleParams.colorShift);
                this.gl.uniform1f(this.uniforms.chaosIntensity, this.variantParams.chaos || 0.0);
                this.gl.uniform1f(this.uniforms.mouseIntensity, this.mouseIntensity);
                this.gl.uniform1f(this.uniforms.clickIntensity, this.clickIntensity);
                this.gl.uniform1f(this.uniforms.densityVariation, this.densityVariation);
                this.gl.uniform1f(this.uniforms.geometryType, this.variant);
                this.gl.uniform1f(this.uniforms.chaos, this.variantParams.chaos || 0.0);
                this.gl.uniform1f(this.uniforms.morph, this.variantParams.morph || 0.0);
                
                this.gl.drawArrays(this.gl.TRIANGLE_STRIP, 0, 4);
            }
        }
        
        // HOLOGRAPHIC CYCLING SYSTEM
        class HolographicCyclingSystem {
            constructor() {
                this.visualizers = [];
                this.currentVariant = 0;
                this.totalVariants = 30;
                this.autoCycleActive = false;
                this.autoCycleInterval = null;
                this.mouseX = 0.5;
                this.mouseY = 0.5;
                this.mouseIntensity = 0.0;
                
                // Variant names for display
                this.variantNames = [
                    'HYPERCUBE LATTICE', 'PLASMA FIELD', 'CRYSTAL MATRIX', 'NEURAL NETWORK', 'QUANTUM FOAM',
                    'FRACTAL DIMENSION', 'HOLOGRAPHIC CORE', 'ENERGY VORTEX', 'PARTICLE STORM', 'WAVE FUNCTION',
                    'TESSELLATION GRID', 'COSMIC WEB', 'DIGITAL RAIN', 'PHOTON STREAM', 'REALITY MESH',
                    'SPACETIME FABRIC', 'QUANTUM TUNNEL', 'STELLAR NURSERY', 'GRAVITATIONAL LENS', 'DARK MATTER',
                    'TEMPORAL FLUX', 'DIMENSIONAL RIFT', 'EXOTIC MATTER', 'VACUUM DECAY', 'FIELD EQUATIONS',
                    'HIGGS FIELD', 'STRING THEORY', 'MULTIVERSE', 'CONSCIOUSNESS', 'EMERGENCE'
                ];
                
                this.initialize();
            }
            
            initialize() {
                console.log('üé® Initializing Holographic Cycling System...');
                
                this.createVisualizers();
                this.setupInteractions();
                this.updateVariantDisplay();
                this.startRenderLoop();
            }
            
            createVisualizers() {
                // Create the 5 visualizers using EXACT tech-layout configuration
                const layers = [
                    { id: 'background-canvas', role: 'background', reactivity: 0.5 },
                    { id: 'shadow-canvas', role: 'shadow', reactivity: 0.7 },
                    { id: 'content-canvas', role: 'content', reactivity: 0.9 }, // EXACT workspace card content
                    { id: 'highlight-canvas', role: 'highlight', reactivity: 1.1 }, // EXACT workspace card highlight
                    { id: 'accent-canvas', role: 'accent', reactivity: 1.5 } // ESSENTIAL translucent overlay
                ];
                
                layers.forEach(layer => {
                    // Use the COMPLETE holographic visualizer from our extracted system
                    const visualizer = new CompleteHolographicVisualizer(layer.id, layer.role, layer.reactivity, this.currentVariant);
                    this.visualizers.push(visualizer);
                });
                
                console.log(`‚úÖ Created 5-layer COMPLETE holographic system with tech-layout extraction ready for 30 variations`);
            }
            
            updateVariant(newVariant) {
                if (newVariant < 0) newVariant = this.totalVariants - 1;
                if (newVariant >= this.totalVariants) newVariant = 0;
                
                this.currentVariant = newVariant;
                
                // Update all visualizers with new variant parameters
                this.visualizers.forEach(visualizer => {
                    visualizer.variant = this.currentVariant;
                    visualizer.variantParams = visualizer.generateVariantParams(this.currentVariant);
                    
                    // Completely regenerate role parameters with new variant values
                    const role = visualizer.role;
                    const vp = visualizer.variantParams;
                    
                    visualizer.roleParams = {
                        'background': { 
                            densityMult: 0.4, speedMult: 0.2, colorShift: 0.0, intensity: 0.2,
                            mouseReactivity: 0.3, clickReactivity: 0.1 
                        },
                        'shadow': { 
                            densityMult: 0.8, speedMult: 0.3, colorShift: 180.0, intensity: 0.4,
                            mouseReactivity: 0.5, clickReactivity: 0.3 
                        },
                        'content': { 
                            densityMult: vp.density, speedMult: vp.speed, 
                            colorShift: vp.hue, intensity: vp.intensity,
                            mouseReactivity: 1.0, clickReactivity: 0.8 
                        },
                        'highlight': { 
                            densityMult: 1.5 + (vp.density * 0.3), speedMult: 0.8 + (vp.speed * 0.2), 
                            colorShift: vp.hue + 60.0, intensity: 0.6 + (vp.intensity * 0.2),
                            mouseReactivity: 1.2, clickReactivity: 1.0 
                        },
                        'accent': { 
                            densityMult: 2.5 + (vp.density * 0.5), speedMult: 0.4 + (vp.speed * 0.1), 
                            colorShift: vp.hue + 300.0, intensity: 0.3 + (vp.intensity * 0.1),
                            mouseReactivity: 1.5, clickReactivity: 1.2 
                        }
                    }[role] || { densityMult: 1.0, speedMult: 0.5, colorShift: 0.0, intensity: 0.5, mouseReactivity: 1.0, clickReactivity: 0.5 };
                });
                
                this.updateVariantDisplay();
                console.log(`üîÑ Switched to variant ${this.currentVariant + 1}: ${this.variantNames[this.currentVariant]}`);
                console.log(`üìä Variant params:`, this.visualizers[2].variantParams); // Log content layer params
            }
            
            updateVariantDisplay() {
                const variantNumber = document.getElementById('variantNumber');
                const variantName = document.getElementById('variantName');
                
                variantNumber.textContent = String(this.currentVariant + 1).padStart(2, '0');
                
                // Get the geometry name from the variant parameters
                const geometryName = this.visualizers[0]?.variantParams?.name || this.variantNames[this.currentVariant];
                variantName.textContent = geometryName;
            }
            
            nextVariant() {
                this.updateVariant(this.currentVariant + 1);
            }
            
            previousVariant() {
                this.updateVariant(this.currentVariant - 1);
            }
            
            randomVariant() {
                const randomIndex = Math.floor(Math.random() * this.totalVariants);
                this.updateVariant(randomIndex);
            }
            
            toggleAutoCycle() {
                this.autoCycleActive = !this.autoCycleActive;
                const btn = document.getElementById('autoCycleBtn');
                const status = document.getElementById('autoCycleStatus');
                
                if (this.autoCycleActive) {
                    btn.textContent = '‚è∏ AUTO';
                    status.textContent = 'Auto-cycle: ON (3s)';
                    this.autoCycleInterval = setInterval(() => {
                        this.nextVariant();
                    }, 3000);
                } else {
                    btn.textContent = '‚ñ∂ AUTO';
                    status.textContent = 'Auto-cycle: OFF';
                    if (this.autoCycleInterval) {
                        clearInterval(this.autoCycleInterval);
                        this.autoCycleInterval = null;
                    }
                }
            }
            
            setupInteractions() {
                // Mouse tracking system
                document.addEventListener('mousemove', (e) => {
                    this.mouseX = e.clientX / window.innerWidth;
                    this.mouseY = 1.0 - (e.clientY / window.innerHeight);
                    this.mouseIntensity = Math.min(1.0, Math.sqrt(e.movementX*e.movementX + e.movementY*e.movementY) / 40);
                    
                    // Update all visualizers
                    this.visualizers.forEach(visualizer => {
                        visualizer.updateInteraction(this.mouseX, this.mouseY, this.mouseIntensity);
                    });
                    
                    // Grid overlay activation
                    const gridOverlay = document.getElementById('gridOverlay');
                    if (this.mouseIntensity > 0.3) {
                        gridOverlay.classList.add('active');
                    } else {
                        gridOverlay.classList.remove('active');
                    }
                    
                    // Density variation
                    const densityVar = Math.sin(this.mouseX * Math.PI) * Math.sin(this.mouseY * Math.PI) * 2.0;
                    this.visualizers.forEach(visualizer => {
                        visualizer.updateDensity(densityVar);
                    });
                });
                
                // Click interactions
                document.addEventListener('click', (e) => {
                    const rect = document.body.getBoundingClientRect();
                    const clickX = (e.clientX - rect.left) / rect.width;
                    const clickY = 1.0 - ((e.clientY - rect.top) / rect.height);
                    
                    // Trigger click effect on all visualizers
                    this.visualizers.forEach(visualizer => {
                        visualizer.triggerClick(clickX, clickY);
                    });
                    
                    // Create ripple effect
                    this.createRipple(e.clientX, e.clientY);
                });
                
                // Keyboard shortcuts
                document.addEventListener('keydown', (e) => {
                    switch(e.key) {
                        case 'ArrowLeft':
                            this.previousVariant();
                            e.preventDefault();
                            break;
                        case 'ArrowRight':
                            this.nextVariant();
                            e.preventDefault();
                            break;
                        case ' ':
                            this.randomVariant();
                            e.preventDefault();
                            break;
                        case 'Enter':
                            this.toggleAutoCycle();
                            e.preventDefault();
                            break;
                    }
                });
            }
            
            createRipple(x, y) {
                const ripple = document.createElement('div');
                ripple.className = 'interaction-ripple';
                ripple.style.left = (x - 50) + 'px';
                ripple.style.top = (y - 50) + 'px';
                document.body.appendChild(ripple);
                
                setTimeout(() => {
                    document.body.removeChild(ripple);
                }, 600);
            }
            
            startRenderLoop() {
                const render = () => {
                    // Render all visualizers
                    this.visualizers.forEach(visualizer => {
                        visualizer.render();
                    });
                    
                    requestAnimationFrame(render);
                };
                
                render();
                console.log('üé¨ Holographic cycling render loop started');
            }
        }
        
        // Global control functions
        function nextVariant() {
            if (window.holographicSystem) {
                window.holographicSystem.nextVariant();
            }
        }
        
        function previousVariant() {
            if (window.holographicSystem) {
                window.holographicSystem.previousVariant();
            }
        }
        
        function randomVariant() {
            if (window.holographicSystem) {
                window.holographicSystem.randomVariant();
            }
        }
        
        function toggleAutoCycle() {
            if (window.holographicSystem) {
                window.holographicSystem.toggleAutoCycle();
            }
        }
        
        // Initialize when page loads
        window.addEventListener('load', () => {
            console.log('üöÄ Initializing Active Holographic Systems - Cycling Demo...');
            const system = new HolographicCyclingSystem();
            window.holographicSystem = system;
        });
        
    </script>
</body>
</html>