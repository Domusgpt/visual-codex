<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>EXTRACTED TECH LAYOUT HOLOGRAPHIC FOIL EFFECT</title>
    <style>
        body { margin: 0; background: #000; overflow: hidden; }
        canvas { display: block; width: 100vw; height: 100vh; }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>

    <script>
        const canvas = document.getElementById('canvas');
        const gl = canvas.getContext('webgl');
        
        if (!gl) alert('WebGL not supported');

        let mouseX = 0.5, mouseY = 0.5, mouseIntensity = 0.0;
        let clickIntensity = 0.0;
        const clickDecay = 0.95;

        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            gl.viewport(0, 0, canvas.width, canvas.height);
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        const vertexShaderSource = `
            attribute vec2 a_position;
            void main() {
                gl_Position = vec4(a_position, 0.0, 1.0);
            }
        `;

        const fragmentShaderSource = `
            precision highp float;
            
            uniform vec2 u_resolution;
            uniform float u_time;
            uniform vec2 u_mouse;
            uniform float u_mouseIntensity;
            uniform float u_clickIntensity;
            uniform float u_densityVariation;
            
            // EXACT 4D rotation matrices from tech-layout
            mat4 rotateXW(float theta) {
                float c = cos(theta);
                float s = sin(theta);
                return mat4(c, 0, 0, -s, 0, 1, 0, 0, 0, 0, 1, 0, s, 0, 0, c);
            }
            
            mat4 rotateYW(float theta) {
                float c = cos(theta);
                float s = sin(theta);
                return mat4(1, 0, 0, 0, 0, c, 0, -s, 0, 0, 1, 0, 0, s, 0, c);
            }
            
            mat4 rotateZW(float theta) {
                float c = cos(theta);
                float s = sin(theta);
                return mat4(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, c, -s, 0, 0, s, c);
            }
            
            // EXACT 4D to 3D projection from tech-layout
            vec3 project4Dto3D(vec4 p) {
                float w = 2.5 / (2.5 + p.w);
                return vec3(p.x * w, p.y * w, p.z * w);
            }
            
            // EXACT tetrahedron lattice from tech-layout
            float tetrahedronLattice(vec3 p, float gridSize) {
                vec3 q = fract(p * gridSize) - 0.5;
                
                // Tetrahedron vertices
                float d1 = length(q);
                float d2 = length(q - vec3(0.4, 0.0, 0.0));
                float d3 = length(q - vec3(0.0, 0.4, 0.0));
                float d4 = length(q - vec3(0.0, 0.0, 0.4));
                
                float vertices = 1.0 - smoothstep(0.0, 0.04, min(min(d1, d2), min(d3, d4)));
                
                // Edge connections
                float edges = 0.0;
                edges = max(edges, 1.0 - smoothstep(0.0, 0.02, abs(length(q.xy) - 0.2)));
                edges = max(edges, 1.0 - smoothstep(0.0, 0.02, abs(length(q.yz) - 0.2)));
                edges = max(edges, 1.0 - smoothstep(0.0, 0.02, abs(length(q.xz) - 0.2)));
                
                return max(vertices, edges * 0.5);
            }
            
            vec3 hsv2rgb(vec3 c) {
                vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
                vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
                return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
            }
            
            // EXACT holographic effects from tech-layout
            vec3 rgbGlitch(vec3 color, vec2 uv, float intensity) {
                vec2 offset = vec2(intensity * 0.005, 0.0);
                float r = color.r + sin(uv.y * 30.0 + u_time * 0.001) * intensity * 0.06;
                float g = color.g + sin(uv.y * 28.0 + u_time * 0.0012) * intensity * 0.06;
                float b = color.b + sin(uv.y * 32.0 + u_time * 0.0008) * intensity * 0.06;
                return vec3(r, g, b);
            }
            
            float moirePattern(vec2 uv, float intensity) {
                float freq1 = 12.0 + intensity * 6.0 + u_densityVariation * 3.0;
                float freq2 = 14.0 + intensity * 8.0 + u_densityVariation * 4.0;
                float pattern1 = sin(uv.x * freq1) * sin(uv.y * freq1);
                float pattern2 = sin(uv.x * freq2) * sin(uv.y * freq2);
                return (pattern1 * pattern2) * intensity * 0.15;
            }
            
            float gridOverlay(vec2 uv, float intensity) {
                vec2 grid = fract(uv * (8.0 + u_densityVariation * 4.0));
                float lines = 0.0;
                lines = max(lines, 1.0 - smoothstep(0.0, 0.02, abs(grid.x - 0.5)));
                lines = max(lines, 1.0 - smoothstep(0.0, 0.02, abs(grid.y - 0.5)));
                return lines * intensity * 0.1;
            }
            
            void main() {
                vec2 uv = gl_FragCoord.xy / u_resolution.xy;
                float aspectRatio = u_resolution.x / u_resolution.y;
                uv.x *= aspectRatio;
                uv -= 0.5;
                
                // EXACT 4D space setup from tech-layout
                float time = u_time * 0.0004 * 0.3; // speed = 0.3 from TECH state
                
                // Mouse influence on rotation  
                float mouseInfluence = u_mouseIntensity * 0.5;
                vec2 mouseOffset = (u_mouse - 0.5) * mouseInfluence;
                
                vec4 p4d = vec4(uv + mouseOffset * 0.1, 
                               sin(time * 0.1) * 0.15, 
                               cos(time * 0.08) * 0.15);
                
                // EXACT 4D rotations from tech-layout
                p4d = rotateXW(time * 0.2 + mouseOffset.y * 0.5) * p4d;
                p4d = rotateYW(time * 0.15 + mouseOffset.x * 0.5) * p4d;
                p4d = rotateZW(time * 0.25 + u_clickIntensity * 0.3) * p4d;
                
                vec3 p = project4Dto3D(p4d);
                
                // EXACT density from TECH state  
                float roleDensity = (4.2 + u_densityVariation) * 0.7; // baseDensity * 0.7 from TECH
                
                // Get tetrahedron geometry for TECH layout
                float lattice = tetrahedronLattice(p, roleDensity);
                
                // EXACT coloring from tech-layout
                float hue = atan(0.0, 1.0) + 0.0 * 0.017453 + u_mouseIntensity * 0.2; // cyan base color
                float saturation = 0.8 + lattice * 0.2 + u_clickIntensity * 0.1;
                float brightness = 0.2 + lattice * 0.8 + 0.7 * 0.2 + u_mouseIntensity * 0.15;
                
                vec3 color = hsv2rgb(vec3(hue, saturation, brightness));
                
                // Add holographic effects
                color += vec3(moirePattern(uv, 0.0)); // chaosIntensity = 0 for clean look
                color += vec3(gridOverlay(uv, u_mouseIntensity));
                color = rgbGlitch(color, uv, 0.0); // no glitch for clean look
                
                // Mouse interaction glow
                float mouseDist = length(uv - (u_mouse - 0.5) * vec2(aspectRatio, 1.0));
                float mouseGlow = exp(-mouseDist * 1.5) * u_mouseIntensity * 0.2;
                color += vec3(mouseGlow) * vec3(0.0, 1.0, 1.0) * 0.6; // cyan glow
                
                // Click pulse effect
                float clickPulse = u_clickIntensity * exp(-mouseDist * 2.0) * 0.3;
                color += vec3(clickPulse, clickPulse * 0.5, clickPulse * 1.5);
                
                gl_FragColor = vec4(color, 0.95);
            }
        `;

        function createShader(type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error('Shader error:', gl.getShaderInfoLog(shader));
                return null;
            }
            return shader;
        }

        const vertexShader = createShader(gl.VERTEX_SHADER, vertexShaderSource);
        const fragmentShader = createShader(gl.FRAGMENT_SHADER, fragmentShaderSource);

        const program = gl.createProgram();
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);
        gl.useProgram(program);

        const positions = new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]);
        const positionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);

        const positionLocation = gl.getAttribLocation(program, 'a_position');
        gl.enableVertexAttribArray(positionLocation);
        gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);

        const uniforms = {
            resolution: gl.getUniformLocation(program, 'u_resolution'),
            time: gl.getUniformLocation(program, 'u_time'),
            mouse: gl.getUniformLocation(program, 'u_mouse'),
            mouseIntensity: gl.getUniformLocation(program, 'u_mouseIntensity'),
            clickIntensity: gl.getUniformLocation(program, 'u_clickIntensity'),
            densityVariation: gl.getUniformLocation(program, 'u_densityVariation')
        };

        let densityVariation = 0.0;

        // Mouse interactions
        document.addEventListener('mousemove', (e) => {
            mouseX = e.clientX / window.innerWidth;
            mouseY = 1.0 - (e.clientY / window.innerHeight);
            mouseIntensity = Math.min(1.0, Math.sqrt(e.movementX*e.movementX + e.movementY*e.movementY) / 40);
            
            // Update density variation based on mouse position
            densityVariation = Math.sin(mouseX * Math.PI) * Math.sin(mouseY * Math.PI) * 2.0;
        });

        document.addEventListener('click', () => {
            clickIntensity = Math.min(1.0, clickIntensity + 0.8);
        });

        function animate(time) {
            clickIntensity *= clickDecay;
            
            gl.uniform2f(uniforms.resolution, canvas.width, canvas.height);
            gl.uniform1f(uniforms.time, time);
            gl.uniform2f(uniforms.mouse, mouseX, mouseY);
            gl.uniform1f(uniforms.mouseIntensity, mouseIntensity);
            gl.uniform1f(uniforms.clickIntensity, clickIntensity);
            gl.uniform1f(uniforms.densityVariation, densityVariation);
            
            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
            requestAnimationFrame(animate);
        }
        
        animate(0);
    </script>
</body>
</html>